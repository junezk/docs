# 如何解决高并发场景下缓存+数据库双写不一致问题?

> 能坚持别人不能坚持的，才能拥有别人不能拥有的。
>
> 文章首发于公众号[编程大道](https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247483972&idx=1&sn=653bea05d73c47556be4461a6037504e&chksm=f9b78475cec00d63771c8d8cbc8be20cdbc69d56ee9c041f42ade77d875e3e351f92344c6dd6&token=812969222&lang=zh_CN#rd)，同步到掘进会延迟一到两天。

**高并发场景下缓存+数据库双写不一致问题分析与解决方案设计**

`Redis`是企业级系统高并发、高可用架构中非常重要的一个环节。Redis主要解决了关系型数据库并发量低的问题，有助于缓解关系型数据库在高并发场景下的压力，提高系统的吞吐量（具体Redis是如何提高系统的性能、吞吐量，后面会专门讲）。

而我们在Redis的实际使用过程中，难免会遇到**缓存与数据库双写时数据不一致**的问题，这也是我们必须要考虑的问题。如果还有同学不了解这个问题，可以搬小板凳来听听啦。

## 一、数据库+缓存双写不一致问题引入

要讲数据库+缓存双写不一致的问题，就需要先讲一下这个问题是怎么发生的。我们选择电商系统中要求数据实时性较高的库存服务来举例讲讲这个问题。

库存可能会修改，每次修改数据库的同时也都要去更新这个缓存数据;；每次库存的数据，在缓存中一旦过期，或者是被清理掉了，前端对库存数据的请求都会发送给库存服务，去获取相应的数据。

库存这一块，写数据库的时候，直接更新redis缓存吗？实际上不是，因为没有这么简单。这里，其实就涉及到了一个问题，数据库与缓存双写，数据不一致的问题。围绕和结合实时性较高的库存服务，把数据库与缓存双写不一致问题以及其解决方案，给大家分享一下。

## 二、各种级别的不一致问题及解决方案

### 1.最初级的缓存不一致问题及解决方案

**问题**

如果是先修改数据库，再删除缓存的方案，会有问题，试想，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，出现数据不一致的情况。

**解决思路**

反过来，先删除缓存，再修改数据库。读缓存读不到，查数据库更新缓存的时候就拿到了最新的库存数据。如果删除缓存成功了，而修改数据库失败了，那么数据库中依旧是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。

### 2.比较复杂的数据不一致问题分析

当库存数据发生了变更，我们先删除了缓存，然后要去修改数据库。

设想一下，如果这个时候修改数据库的操作还没来及完成，突然一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。

数据变更的操作完成后数据库的库存被修改成了新值，但缓存中又变成了旧数据。那么这个时候是不是还会出现缓存和数据库不一致的情况？

### 3.为何上亿流量高并发时会出现该问题？

上述问题，只有在对一个数据在并发的进行读写的时候，才可能会出现。

其实如果并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。

但是问题是，高并发了以后，问题是很多的。如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。

怎么解决？

### 4.更新与读取操作进行异步串行化

这里说一种解决方案。

不就是还没更新数据库的就查数据库读到旧数据吗？不就是因为读在更新前面了吗？那我就让你排队执行呗。

#### 4.1 异步串行化

我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。

这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。

#### 4.2 读操作去重

多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回； 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）

### 5.高并发的场景下，该方案要注意的问题

高并发的场景下，该解决方案其实还是有一些问题需要特别注意的。

#### 5.1 读请求长时阻塞

由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。

该解决方案，最大的风险点在于，数据更新很频繁的情况下导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库取到了旧值。所以，务必通过一些模拟真实的测试，看看更新数据频繁的场景下是怎样的。

另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，确定一个实例中创建多少个内存队列，且可能需要部署多个服务，每个服务分摊一些数据的更新操作。

如果一个内存队列里积压100个商品的库存修改操作，每个库存修改操作要耗费10ms去完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据。

这个时候就导致读请求的长时阻塞。

一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会hang多少时间。如果读请求在200ms返回，而且你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以的。

如果一个内存队列可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。

> **Tips**:
> 其实根据之前的项目经验，一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。
>
> 针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了。
>
> 假如一秒500的写操作，可以看成5份，每200ms就100个写操作。对于单机器，如果又20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成。
>
> 那么针对每个内存队列中的数据的读请求，也就最多hang一会儿，200ms以内肯定能返回了。
>
> 假如写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列。
>
> 大部分的情况下，应该是这样的：大量的读请求过来，都是直接走缓存取到数据的。少量情况下，可能遇到读和数据更新冲突的情况。如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面。
>
> 等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据。

#### 5.2 读请求并发量过高

这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值。

但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。

> Tips:
> 如果按1:99的比例计算写和读的请求，那么每秒5万的读QPS，可能只有500次更新操作。
> 如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条数据在缓存中失效后，可能导致多少读缓存的请求，发送读请求到库存服务来，要求更新缓存。
>
> 一般来说，按1:2的话，每秒钟有1000个读请求去读这500个正在更新库的数据，就会有1000个请求hang在库存服务上，如果规定每个请求200ms就返回，那么每个读请求最多hang多少时间，这个一定要测算好。
>
> 在同一时间最多hang住的可能也就是单机200个读请求，最坏的同时hang住，单机hang200个读请求，还是ok的。
>
> 但是假如1:20，每秒更新500条数据，这500秒数据对应的读请求，会有20 * 500 = 1万，1万个读请求全部hang在库存服务上，就死定了。

#### 5.3 多服务实例部署的请求路由

可能这个库存服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，对于同一商品的读写请求全部路由到同一台机器上。可以自己去做服务间的按照某个请求的参数做hash路由，也可以通过nginx服务器hash路由的功能路由到相同的服务实例上。

#### 5.4 热点商品的路由问题，导致请求的倾斜

万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大。

但是因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大。

但是的确可能某些机器的负载会高一些。

## 三、总结

一般来说，就是如果你的系统**不是严格要求**缓存+数据库必须**一致性**的话，缓存可以稍微的跟数据库偶尔有不一致的情况，那最好**不要**上述的**串行化**的这个方案，因为读请求和写请求串行化，串到一个内存队列里去，这样是可以保证一定不会出现不一致的情况。但是，串行化之后，就会导致系统的**吞吐量会大幅度的降低**，你就需要用比正常情况下多几倍的机器去支撑线上的一个请求。

另外，不是说，讲课的、写文章的就是超人，万能的。就跟写书一样，很可能会写错，也可能有些方案里的一些地方，没考虑到。或者有些方案只是适合某些场景，在某些场景下，可能需要你进行方案的优化和调整才能适用于你自己的项目。

如果大家觉得对这些方案有什么疑问或者见解，都可以沟通交流。如果的确觉得是讲解的不对，或者有些地方考虑不周，那么都是可以交流的，多多包涵。