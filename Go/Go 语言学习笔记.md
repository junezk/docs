# Go 语言学习笔记

## go语言25个关键字

- `var`和`const` ：变量和常量的声明，`var` varName type  或者 varName : = value
- `package` and `import`： 导入
- `func`： 用于定义函数和方法
- `return` ：用于从函数返回
- `defer` someCode ：在函数退出之前执行
- `go` : 用于并行
- `select` 用于选择不同类型的通讯
- `interface` 用于定义接口
- `struct`用于定义抽象数据类型
- `break`、`case`、`continue`、`for`、`fallthrough`、`else`、`if`、`switch`、`goto`、`default` 流程控制
- `chan`用于channel通讯
- `type`用于声明自定义类型
- `map`用于声明map类型数据
- `range`用于读取slice、map、channel数据

## go 中数组 `array`、切片 `slice`

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**数组的长度是数组类型**的一个部分，**不同长度或不同类型的数据组成的数组都是不同的类型**，因此在**Go语言中很少直接使用数组**（不同长度的数组因为类型不同无法直接赋值）。和数组对应的类型是切片，切片是可以动态增长和收缩的序列，切片的功能也更加灵活。

### 数组定义

```go
var a [3]int                    // 定义一个长度为3的int类型数组, 元素全部为0
var b = [...]int{1, 2, 3}       // 定义一个长度为3的int类型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义一个长度为3的int类型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义一个长度为6的int类型数组, 元素为 1, 2, 0, 0, 5, 6
// ...省略号出现在数组长度的位置，表明数组长度由初始化元素的个数决定
```

数组变量被赋值或者被传递的时候，实际上会复制整个数组，如果数组较大的话，数组的赋值也会有较大的开销。**为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。**

内置函数len可以用于计算数组的长度，cap函数可以用于计算数组的容量。

### 数组遍历

```go
for i := range a {
	fmt.Printf("a[%d]: %d\n", i, a[i])
}
for i, v := range b {
    fmt.Printf("b[%d]: %d\n", i, v)
}
for i := 0; i < len(c); i++ {
    fmt.Printf("c[%d]: %d\n", i, c[i])
}
var times [5][0]int
for range times {			// 忽略迭代时的下标
    fmt.Println("hello")
}
```

用`for range`方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断。

可以用`fmt.Printf`函数提供的`%T`或`%#v`谓词语法来打印数组的类型和详细信息：

```go
fmt.Printf("b: %T\n", b)  // b: [3]int
fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```

切片表示拥有相同类型元素的可变长度的序列。切片有三个属性：指针、长度和容量，长度是切片中元素的个数，容量是从切片起始元素到底层数组最后一个元素间元素个数，具体见《GO语言程序设计》4.2节。容量必须大于等于长度。len可以用于计算数组的长度，cap函数可以用于计算数组的容量。切片的底层实现还是数组。

**切片无法做比较，数组可以。**

### 切片定义

```go
slice := make([]int, 5)    	// 通过 make() 函数创建切片，长度和容量为 5
slice := make([]int, 3, 5)  // 创建切片，其长度为 3，容量为 5
myStr := []string{"Jack", "Mark", "Nick"}  // 通过字面量创建切片
myStr := []string{99: ""}   // 通过字面量创建切片，长度和容量为 100
newNum := slice[1:3]    	// 通过切片创建新的切片，原则是 "左含右不含"
```

> **提示**：尽可能指定容器容量，以便为容器预先分配内存。这将在后续添加元素时减少通过复制来调整容器大小。

### 切片扩容

Golang 内置的 append() 函数可以按需增加切片的容量，会返回一个包含修改结果的新切片。函数 append() 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。

函数 append() 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%的容量（因子并非固定，可能随着Go语言版本而改变）。

### 将一个切片追加到另一个切片

使用 … 运算符，可以将一个切片的所有元素追加到另一个切片里：

```go
// 创建两个切片，并分别用两个整数进行初始化
num1 := []int{1, 2}
num2 := []int{3, 4}
// 将两个切片追加在一起，并显示结果
fmt.Printf("%v\n", append(num1, num2...))  // 输出的结果为：[1 2 3 4]
```

### 切片间的拷贝

Golang 内置的 copy() 函数可以将一个切片中的元素拷贝到另一个切片中，其函数声明为：

```swift
func copy(dst, src []Type) int
```

它表示把切片 src 中的元素拷贝到切片 dst 中，返回值为拷贝成功的元素个数。如果 src 比 dst 长，就截断；如果 src 比 dst 短，则只拷贝 src 那部分：

```go
num1 := []int{10, 20, 30}
num2 := make([]int, 5)
count := copy(num2, num1)
fmt.Println(count)		// 3
fmt.Println(num2)		// [10 20 30 0 0]
```

## go中的散列表 `map`

散列表表示的是键值对之间映射关系，是这些键值对的**无序**集合。

### map定义

```go
ages := make(map[string]int)  // make 函数来定义
ages := map[string]int{
    "alice": 21,
    "jack": 18,
}    // 根据初始值来定义
```

使用`delete`来移除某个map元素：`delete ages['alice']`

go中的
