# Docker 最佳实践

很多人最终还是决定使用 Docker 解决问题。

Docker 的优点很多，比如：

一体化——将操作系统、库版本、配置文件、应用程序等全部打包装在容器里。从而保证 QA 所测试的镜像 (image) 会携带同样的行为到达生产环境。

轻量——内存占用极小，只为主要过程分配内存。

快读——一键启动，就像启动常见的 linux 过程一样快。

尽管如此，众多用户仍然只是把容器当做常见的虚拟机，而忘记了容器的一个重要特性：

用后即弃

正因为这一特点，一些用户需要改变他们对容器的观念，为了更好的使用与发挥 Docker 容器的价值，有一些事情是绝对不应该做的：

## Docker 构建最佳实践

### 1.不要在容器（container）中存储数据

容器可能会被中断、被替换或遭到破坏。在容器中运行的 1.0 版应用程序很容易就会被 1.1 版取代，而不会对数据造成影响或导致数据丢失。因此，如果需要存储数据，请存储在卷 (volume) 中。在这一情况下，还应注意两个容器是否会在同一个卷上写入数据，这将导致损坏。请确保应用程序适用于写入共享的数据存储。

### 2.不要分两部分传送应用程序

有些人把容器当作虚拟机，所以他们大多会认为，应该将应用程序部署到现有正在运行的容器中。在需要不断部署和调试的开发阶段，可能确实如此；但对于 QA 和生产的持续交付 (CD) 渠道，应用程序应当是镜像的一部分。切记：容器转瞬即逝。

### 3.不要创建大尺寸镜像

大尺寸的镜像难以分配。请确保仅使用必需文件和库来运行应用程序。不要安装不必要的数据包，也不要运行“更新”(yum update)，这些操作会把大量文件下载到新的镜像层。

### 4.不要使用单层镜像

为了有效利用多层文件系统，请始终为操作系统创建属于自己的基本镜像层，然后为用户名定义创建一个层，为运行时安装创建一个层，为配置创建一个层，最后再为应用程序创建一个层。这样，重新创建、管理和分配镜像就会容易些。

### 5.不要从正在运行的容器中创建镜像

换句话说，不要使用"docker commit"命令来创建镜像。这一镜像创建方法不可复制，因此应完全避免使用。请始终使用 Dockerfile 或其他任何可完全复制的 S21（从源代码到镜像）方法，如此一来，如果存储在源代码控制存储库 (GIT) 中，就可以跟踪 Dockerfile 的变更情况。

### 6.不要只使用“最新版”标签

最新版标签就像 Maven 用户的“快照”(SNAPSHOT) 一样。容器具有多层文件系统这一基本特征，所以我们鼓励使用标签。相信谁也不愿意在构建了几个月的镜像后，突然发现应用程序因为父层（即 Dockerfile 中的 FROM）被新版本取代而无法运行（新版本无法向后兼容或从构建缓存中检索的“最新“版有误）这样的意外吧？在生产过程中部署容器时也应避免使用”最新版“标签，这是因为无法跟踪当前运行的镜像版本。

### 7.不要在单个容器中运行一个以上进程

容器只运行一个进程（HTTP 守护进程、应用程序服务器、数据库）时效果最佳，但如果运行一个以上进程，在管理和检索日志以及单独更新进程时就会遇到很多麻烦。

### 8.不要在镜像中存储证书及使用环境变量。

不要在镜像中对任何用户名/密码进行硬编码操作。请使用环境变量从容器外部检索信息。Postgres 镜像就是这一原理的极佳诠释。

### 9.不要以 root 权限运行进程

“默认情况下，Docker 容器以 root 用户权限运行。（……）随着 Docker 技术日趋成熟，能够使用的安全默认选项越来越多。目前，要求 root 对其他用户来说较为危险，另外，不是所有环境都能够使用 root。镜像应使用 USER 指令来为容器的运行指定非 root 用户。”（摘自《Docker 镜像作者指南》(Guidance for Docker Image Authors)）

### 10.不要依赖 IP 地址

每个容器都有自己的内部 IP 地址，如果启动然后停止容器，内部 IP 地址可能会发生变化。如果你的应用程序或微服务需要和另一个容器进行通信，请使用环境变量在容器之间传递相应的主机名和端口。

### 11.监控容器

Docker 监控已经越来越受到开发者们的重视，实时监控 Docker 的方法，这里推荐 Cloudinsight。 不同于一些需要自写脚本的监控手段，Cloudinsight 作为一家免费的 SaaS 服务，能够一键监控 Docker，且拥有很棒的可视化界面。除此之外，Cloudinsight 还支持多种操作系统、数据库等的监控，能够一体化展示所有被监控的系统基础组件的性能数据。

## Dockerfile最佳实践

### 1. 减少构建时间

一个开发周期包括构建 Docker 镜像，更改代码，然后重新构建 Docker 镜像。在构建镜像的过程中，如果能够利用缓存，可以减少不必要的重复构建步骤。

#### 构建顺序影响缓存的利用率

![img](Docker 十一条最佳实践.assets/16bd6e5d5bc95c4d)

镜像的构建顺序很重要，当你向 Dockerfile 中添加文件，或者修改其中的某一行时，那一部分的缓存就会失效，该缓存的后续步骤都会中断，需要重新构建。**所以优化缓存的最佳方法是把不需要经常更改的行放到最前面，更改最频繁的行放到最后面。**

#### 只拷贝需要的文件，防止缓存溢出

![img](Docker 十一条最佳实践.assets/16bd6e5d5bd69817)

当拷贝文件到镜像中时，尽量只拷贝需要的文件，切忌使用 `COPY .` 指令拷贝整个目录。如果被拷贝的文件内容发生了更改，缓存就会被破坏。在上面的示例中，镜像中只需要构建好的 jar 包，因此只需要拷贝这个文件就行了，这样即使其他不相关的文件发生了更改也不会影响缓存。

#### 最小化可缓存的执行层

![img](Docker 十一条最佳实践.assets/16bd6e5d5c957fdb)

每一个 `RUN` 指令都会被看作是可缓存的执行单元。太多的 RUN 指令会增加镜像的层数，增大镜像体积，而将所有的命令都放到同一个 RUN 指令中又会破坏缓存，从而延缓开发周期。当使用包管理器安装软件时，一般都会先更新软件索引信息，然后再安装软件。推荐将更新索引和安装软件放在同一个 RUN 指令中，这样可以形成一个可缓存的执行单元，否则你可能会安装旧的软件包。

### 2. 减小镜像体积

镜像的体积很重要，因为镜像越小，部署的速度更快，攻击范围越小。

#### 删除不必要依赖

![img](Docker 十一条最佳实践.assets/16bd6e5d5ca53e33)

删除不必要的依赖，不要安装调试工具。如果实在需要调试工具，可以在容器运行之后再安装。某些包管理工具（如 `apt`）除了安装用户指定的包之外，还会安装推荐的包，这会无缘无故增加镜像的体积。apt 可以通过添加参数 `-–no-install-recommends` 来确保不会安装不需要的依赖项。如果确实需要某些依赖项，请在后面手动添加。

#### 删除包管理工具的缓存

![img](Docker 十一条最佳实践.assets/16bd6e5d611c15e7)



包管理工具会维护自己的缓存，这些缓存会保留在镜像文件中，推荐的处理方法是在每一个 RUN 指令的末尾删除缓存。如果你在下一条指令中删除缓存，不会减小镜像的体积。

当然了，还有其他更高级的方法可以用来减小镜像体积，如下文将会介绍的多阶段构建。接下来我们将探讨如何优化 Dockerfile 的可维护性、安全性和可重复性。

### 3. 可维护性

#### 尽量使用官方镜像

![img](Docker 十一条最佳实践.assets/16bd6e5d5c992553)

使用官方镜像可以节省大量的维护时间，因为官方镜像的所有安装步骤都使用了最佳实践。如果你有多个项目，可以共享这些镜像层，因为他们都可以使用相同的基础镜像。

#### 使用更具体的标签

![img](Docker 十一条最佳实践.assets/16bd6e5dda05e717)

基础镜像尽量不要使用 `latest` 标签。虽然这很方便，但随着时间的推移，latest 镜像可能会发生重大变化。因此在 Dockerfile 中最好指定基础镜像的具体标签。我们使用 `openjdk` 作为示例，指定标签为 8。其他更多标签请查看[官方仓库](https://link.juejin.im?target=https%3A%2F%2Fhub.docker.com%2F_%2Fopenjdk)。

#### 使用体积最小的基础镜像

![img](Docker 十一条最佳实践.assets/16bd6e5e0911e782)

基础镜像的标签风格不同，镜像体积就会不同。`slim` 风格的镜像是基于 Debian 发行版制作的，而 `alpine` 风格的镜像是基于体积更小的 Alpine Linux 发行版制作的。其中一个明显的区别是：Debian 使用的是 GNU 项目所实现的 C 语言标准库，而 Alpine 使用的是 Musl C 标准库，它被设计用来替代 GNU C 标准库（glibc）的替代品，用于嵌入式操作系统和移动设备。因此使用 Alpine 在某些情况下会遇到兼容性问题。 以 openjdk 为例，`jre` 风格的镜像只包含 Java 运行时，不包含 `SDK`，这么做也可以大大减少镜像体积。

### 4. 重复利用

到目前为止，我们一直都在假设你的 jar 包是在主机上构建的，这还不是理想方案，因为没有充分利用容器提供的一致性环境。例如，如果你的 Java 应用依赖于某一个特定的操作系统的库，就可能会出现问题，因为环境不一致（具体取决于构建 jar 包的机器）。

#### 在一致的环境中从源代码构建

源代码是你构建 Docker 镜像的最终来源，Dockerfile 里面只提供了构建步骤。

![img](Docker 十一条最佳实践.assets/16bd6e5e09372171)

首先应该确定构建应用所需的所有依赖，本文的示例 Java 应用很简单，只需要 `Maven` 和 `JDK`，所以基础镜像应该选择官方的体积最小的 maven 镜像，该镜像也包含了 JDK。如果你需要安装更多依赖，可以在 RUN 指令中添加。`pom.xml` 文件和 `src` 文件夹需要被复制到镜像中，因为最后执行 `mvn package` 命令（-e 参数用来显示错误，-B 参数表示以非交互式的“批处理”模式运行）打包的时候会用到这些依赖文件。

虽然现在我们解决了环境不一致的问题，但还有另外一个问题：**每次代码更改之后，都要重新获取一遍 pom.xml 中描述的所有依赖项。**下面我们来解决这个问题。

#### 在单独的步骤中获取依赖项

![img](Docker 十一条最佳实践.assets/16bd6e5e0ac348fb)

结合前面提到的缓存机制，我们可以让获取依赖项这一步变成可缓存单元，只要 pom.xml 文件的内容没有变化，无论代码如何更改，都不会破坏这一层的缓存。上图中两个 COPY 指令中间的 RUN 指令用来告诉 Maven 只获取依赖项。

现在又遇到了一个新问题：跟之前直接拷贝 jar 包相比，镜像体积变得更大了，因为它包含了很多运行应用时不需要的构建依赖项。

#### 使用多阶段构建来删除构建时的依赖项

![img](Docker 十一条最佳实践.assets/16bd6e5e0ef193d7)

多阶段构建可以由多个 FROM 指令识别，每一个 FROM 语句表示一个新的构建阶段，阶段名称可以用 `AS` 参数指定。本例中指定第一阶段的名称为 `builder`，它可以被第二阶段直接引用。两个阶段环境一致，并且第一阶段包含所有构建依赖项。

第二阶段是构建最终镜像的最后阶段，它将包括应用运行时的所有必要条件，本例是基于 Alpine 的最小 JRE 镜像。上一个构建阶段虽然会有大量的缓存，但不会出现在第二阶段中。为了将构建好的 jar 包添加到最终的镜像中，可以使用 `COPY --from=STAGE_NAME` 指令，其中 STAGE_NAME 是上一构建阶段的名称。

![img](Docker 十一条最佳实践.assets/16bd6e5e137c76cc)

多阶段构建是删除构建依赖的首选方案。

本文从在非一致性环境中构建体积较大的镜像开始优化，一直优化到在一致性环境中构建最小镜像，同时充分利用了缓存机制。下一篇文章将会介绍多阶段构建的更多其他用途。