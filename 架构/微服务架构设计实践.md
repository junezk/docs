# 微服务架构设计实践

## 1  序言

最近，在软件架构设计领域，微服务非常火。

一提到软件开发、架构设计，如果不提微服务，不说说微服务的架构风格，那就落伍了，OUT了。

当然了，支持微服务的技术也是层出不穷，如微服务1.0中比较有名的来自Spring家族的Spring Cloud，以及国内在开源领域的翘楚阿里系中的Dubbo。其中，Spring Cloud提供了完整的微服务解决方案，为开发者提供了快速构建分布式系统的通用模型的工具，包括配置管理、服务发现、熔断器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态等。而Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及服务治理方案。

随着微服务的持续火热，微服务2.0中的ServiceMesh也火起来了。Service Mesh，即“服务网格”，作为服务间通信的基础设施层，Service Mesh可以被看作是微服务间的TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写服务的开发人员来说，一般无须关心TCP/IP这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用Service Mesh也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如Spring Cloud、OSS，现在只要交给Service Mesh就可以了。

其实，上述说了那么多，介绍了那么多，基本都是集中在概念层面，在理论的层次上，以及支持微服务的开发技术、开发框架上，缺少这些概念、理论、技术和框架在实际项目中具体地应用。

对于大多数开发人员、架构师来说，除了理解微服务相关的概念，熟悉微服务相关的技术和框架，更关心如何在实际的项目中，应用这些概念、技术和框架。而这些，正是现在所欠缺的。

笔者从事软件开发多年，参与和指导过多个项目的架构设计，经历过单体架构、分布式架构、SOA架构，对软件架构的发展历史有一定的了解。

同时，在架构设计过程中，笔者也拜读了多位架构大师的著作，如温昱老师的《软件架构设计》、《一级架构师》，Peter Eeles和Peter Cripps的《软件架构设计的过程》等，以及各位技术大咖们在互联网上分享的各类架构相关的文档，使我受益匪浅。在此，我衷心的对这些前辈们表示由衷的感谢，谢谢你们对于知识的分享，以及无私奉献的精神。

最近，笔者有幸参与了某银行的一个采用微服务架构风格的项目，实践了一下微服务架构。

更确切地说，该项目是分布式服务架构向微服务架构的演进，使用更细粒度的服务和一组设计准则来考虑大规模的、复杂的系统架构设计，并非一个纯粹的微服务架构风格的项目。

秉着知识共享的精神，笔者写了这篇“微服务架构设计实践”的文章，一方面是对自己在架构设计方面的一个阶段性总结，另一方面是希望给其他刚刚从事软件架构设计的人员一个真实的、具体的软件架构过程的实践参考，为他们提供一个完整的实践案例。

在写这篇文章的过程中，在介绍微服务、软件架构设计思想的概念、方法论时，引用了各位大师、技术大咖们关于微服务、架构设计的文章中的内容，在此衷心地表示感谢。对于引用的内容，笔者并非简单地摘抄，而是结合笔者的理解和实践，做了适当的调整。如果存在不适、错误的地方，希望各位及时地指出，我将积极的采纳和修改。

## 2  微服务

### 2.1  微服务的定义

微服务是一个独立、可部署的服务，它只专注做一件事情并且做好，而这个事情通常可以是业务能力，或者提供业务价值的最小单元服务。

微服务的描述具有一般服务描述所遵循的内容：

1. 使用明确的接口方式，如：WebService、Rest。

2. 描述里应该包括约束和策略，如：参数、返回值，以及使用什么通讯协议和数据格式等。

微服务中“微”是其独特个性的体现，“微”表示“接口粒度细”。

简而言之，微服务的特征归结为：

1. 职责单一，相对独立。

2. 接口粒度细。

3. 轻量级通讯协议。

4. 服务之间松耦合。

### 2.2  微服务架构的定义

James Lewis 和 Martin Fowler 给微服务架构的定义如下：

- 微服务架构风格指将复杂系统切分为几十甚至上百个小服务，每个服务负责实现一个独立的业务逻辑。系统中的各个服务通常是独立部署，彼此之间是松耦合的。

- 每个服务都运行在自己的进程中，一般采用Rest API风格的轻量级通讯协议进行相互通信。

- 这些服务围绕业务功能进行构建，通过全自动化的部署方式来进行独立部署。

- 这些服务可以使用不同的语言来编写，也可以使用不同的数据存储技术，并且基于最低限度的集中管理。


### 2.3  微服务架构的特征

Martin Fowler 认为，微服务架构具有如下 9 个特性：

1. 组件以服务的形式提供。

2. 围绕业务功能进行组织。

3. 产品而不是项目。

4. 强化终端与弱化管道。

5. “去中心化” 地治理技术。

6. “去中心化” 地管理数据。

7. “基础设施” 自动化。

8. “容错” 设计。

9. “演进式” 设计。

### 2.4  微服务架构的优缺点

微服务架构的优点在于：

1. 更加彻底的组件化，系统内部各个组件之间解耦的比较干脆，单个系统的规模小很多。

2. 可以组建每个服务独立的维护团队，利于各自团队独立的开发和维护。

3. 每个微服务独立部署，只要服务间的接口稳定，各系统可以相互之间互不干扰的独立发展。

4. 微服务架构使得每个服务本身可以独立的扩展，性能出现瓶颈，优化或增加这个服务的配置即可。

微服务架构的缺点在于：

1.	微服务强调了服务大小，但实际上，业界并没有给出一个明确的、统一的标准。业务逻辑应该按照什么规则划分为微服务，这本身就是一个经验工程。但要记住，微服务是达到目的的手段，而不是目标。微服务的目标是充分分解应用程序，以促进敏捷开发和持续集成部署。

2.	它的分布式特点带来的复杂性。开发人员需要基于RPC或者消息实现微服务之间的调用和通信，而这就使得服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手。

微服务架构所面临的挑战：

1. 分区的数据库体系和分布式事务。在微服务架构下，不同服务可能拥有不同的数据库。CAP原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性，这个对开发人员来说是一个挑战。

2. 对测试带来了很大的挑战。对微服务进行测试，需要启动它依赖的所有其他服务，这种复杂性不可低估。

3. 对跨多个服务的更改带来的挑战。在微服务架构中，若有A、B、C三个服务需要更改，A依赖B，B依赖C。此时，我们需要仔细规划和协调每个服务的变更部署，可能需要先更新C，然后更新B，最后更新A。

4. 部署基于微服务的应用也要复杂得多。微服务由不同的大量服务构成，每种服务拥有自己的配置、应用实例数量以及基础服务地址，这里就需要不同的配置、部署、扩展和监控组件。此外，我们还需要服务发现机制，以便服务可以发现与其通信的其他服务的地址。因此，成功部署微服务应用需要开发人员有更好地部署策略和高度自动化的水平。

基于上述的微服务存在的优缺点，以及微服务架构设计过程中面临的挑战，建议在软件架构设计时，不要从一开始就以微服务架构作为系统设计的起点。相反地，要用一个单个系统作为起点，并保持其模块化。当这个系统出现了问题后，再将其分解为微服务。

## 3  软件架构设计思想

### 3.1  软件架构定义

对于软件架构的定义，仁者见仁，智者见智。目前，业界比较流行的两大流派是组成派和决策派，这两派的概念相辅相成，具体如下：

组成派：软件架构 = 组件 + 交互。

决策派：软件架构 = 重要决策集。

上述两大流派的描述过于抽象，不利于理解，本人更喜欢下述关于软件架构的描述，通俗易懂，即：

软件架构是软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。软件架构描述的对象是直接构成系统的抽象组件，各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。

软件架构是一个用于指导系统实现的草图，这个草图越详细对于系统实现的指导意义越重大，贯穿于软件的整个生命周期。

### 3.2  软件架构本质

架构的本质就是对系统进行有序化重构，不断减少系统无序的程度，使系统不断进化。

架构从无序到有序的基本实现手段是分和合，即先把系统打散，然后重新组合。

分的过程是把系统拆分为各个子系统、模块、组件。拆分的时候，首先要解决每个组件的定位问题，然后才能划分彼此的边界，实现合理的拆分。合的过程就是根据最终要求，把各个分离的组件有机整合在一起。

分的结果使开发人员能够做到业务聚焦、技能聚焦，实现开发敏捷；

合的结果使系统变得柔性，可以因需而变，实现业务敏捷。

相对来说，第一步的拆分更难。

### 3.3  软件架构过程

在此次软件架构设计过程中，采用了温昱老师在《软件架构设计》一书中提及的ADMEMS方法体系。

ADMEMS方法通过3个阶段和一个贯穿环节，来覆盖“需求进，架构出”的完整架构设计过程。

​         ![img](微服务架构设计实践.assets/20180407145446882)

#### 3.3.1  PA阶段

架构准备阶段是架构设计的第一个阶段，此阶段的工作目标是：理解需求，建立需求大局观，确定架构设计方向等。

功能需求、质量属性和约束共同决定了架构，对这3类需求的把握是否到位、设计决策是否对路，是软件架构设计的关键所在。

如果可能的话，架构师应该尽早的参与需求分析工作，对需求进行大局的梳理，而不能被动地等待《软件需求规格说明书》的完成。

只要满足以下3个条件，架构师就可以开始架构设计工作：

1.明确的业务需求：甲、乙双方对系统的目标达成共识，《愿景文档》通过了正式评审，并且明确了投资、工期标准、整合等约束条件。

2.全面的用户需求：系统范围明确，即系统能帮用户干什么，不能干什么。

3.典型的行为需求：核心功能的《用例规约》已定义。

在架构准备阶段，通过对软件需求的详细分析，抽取出确定概念性架构所需要的关键需求。

此阶段的输入是软件需求（即上述的三部分：明确的业务需求、全面的用户需求、典型的行为需求），成果物是确定的关键需求，包括关键功能、关键质量属性和关键约束影响，作为下一个阶段的输入。

#### 3.3.2  CA阶段

概念架构是对系统设计的最初构想，对大型系统的成功非常关键。

概念性架构定义了系统的高层组件，笼统地界定了高层组件的职责，以及它们之间的关系。

概念性架构主要是对系统进行适当的分解，而不陷入细节。

概念性架构规定了每个组件的非正式规约及架构图，但不涉及接口细节。

    在进行概念架构设计时，必须牢牢抓住重大需求、特色需求、高风险需求，有针对性地确定解决方案。

关键需求塑造概念架构。反过来，概念架构体现关键需求。

此阶段的输入是关键需求，包括关键功能、关键质量属性和关键约束影响，成果物是针对关键问题的解决策略，和以高层抽象组件方式描述的整个系统的组成草图，可以用在《软件方案建议书》。此成果物作为下一个阶段的输入。

#### 3.3.3  RA阶段

        从概念架构到细化架构，先设计概念架构，构思关键问题的解决策略；再进行细化架构的设计，以保证为开发提供足够的指导和限制。

在细化架构阶段，整体设计思路为以分而治之为核心思想的多视图方法。

此阶段的输入是关键问题的解决策略，和以高层抽象组件方式描述的整个系统的组成草图，成果物是描述系统的各种视图，这些视图从不同的角度，不同的关注点，描述了抽象的、完整的系统解决方案。

### 3.4  软件架构视图

多视图方法是业界广泛认可的一种架构设计思路。

一种优秀的多视图方法，应该能够比较完善地覆盖架构设计的各项工作内容，并且将每项工作内容明确地、有理有据地、一目了然地划归到不同的架构视图中去。

在多视图方法中，每个视图都从一个思维角度聚焦一组技术关注点，都从特定角度规划系统的拆分和组合，都是架构的一种体现。

多视图方法种类繁多，其中影响最大的当属由Philippe Kruchten于1995年首次提出的RUP的4+1视图方法，涉及视图分别为逻辑架构视图、运行架构视图、开发架构视图、数据架构视图、物理架构视图。

另一种在架构设计中经常使用的多视图方法是联邦企业架构框架（Federal Enterprise Architecture Framework），涉及视图分别为：业务架构视图、数据架构视图、应用架构视图、技术架构视图。

本人所使用的视图方法是以RUP的4+1视图方法和联邦企业架构框架为基础，基于本人在架构设计方面的实践经验，总结出常用的6中架构视图，涉及视图为：业务架构视图、数据架构视图、应用架构视图、技术架构视图、物理架构视图、开发架构视图。

为了理论与实践相结合，对于每种视图的介绍放到架构设计实践的细化架构阶段，结合实际的项目，详细描述每种视图。

### 3.5  架构之间的关系

从根本上讲，架构设计毫无疑问是需求驱动的。所以，软件需求是整个软件架构设计过程的前提条件。

在架构设计过程中，不同的架构视图之间并不是孤立存在的，它们之间存在着依赖关系，并且这些依赖关系也决定了这些架构视图的设计顺序，具体如下：

1.	第一步，根据用户需求确定业务架构。

2.	第二步，根据业务架构，分析、定义数据架构。

3.	第三步，根据数据架构，并结合功能需求定义应用架构。

4.	第四步，根据数据架构与应用架构来设计技术架构。

5.	第五步，根据数据架构、应用架构和技术架构，来设计开发架构。

## 4  微服务架构设计实践

### 4.1  项目概述

为了支持分行特色业务在某银行科技总体架构下高效、规范实施，总行构建了分行特色业务云平台，旨在为分行应用提供全面、易用、统一、安全可靠的服务能力，包括业务能力和技术能力，降低对于总行产品模块的接入难度，整体控制接入风险，同时整合、集成总行服务能力。

分行特色业务云平台是一套以总分协同、共享服务体系架构的分行特色业务开发平台。该平台基于行方自主研发的Tesla基础技术框架，实现全分行统一、规范技术支撑架构，为分行应用提供全面、易用、安全可靠的服务。以此为基石，更深、更广泛的发挥全分行科技人员开发能力和对业务支持响应能力。

此次设计的分行特色业务云平台以Tesla平台作为技术载体，采用分布式服务框架理论作为设计依据，在此基础上，构建JAVA版特色业务分平台（JCAP-Java Cloud Application Platform）、服务融合中心（SCC-Service Convergence Center）。

服务融合中心在本次分行特色业务平台的定位是对分行特色业务提供各种总行后台模块的服务能力，并且对分行特色业务的接入做到统一管理和差异化控制功能。

### 4.2  架构准备阶段

在架构准备阶段，主要是分析用户的需求，推荐采用“ADMEMS矩阵”矩阵方法进行需求结构化，即“需求层次-需求方面矩阵”。

通过业务级需求、用户级需求、开发级需求三个层次，功能、质量、约束三个方面对用户需求进行二维需求观分析，抽取出决定架构的关键需求。

ADMEMS矩阵如下图所示：

![img](微服务架构设计实践.assets/20180407150349975)


以下是分行特色业务云平台的关键需求，主要包括关键约束、关键质量和关键功能。

另外，根据这些关键需求，抽象出业务架构视图，从业务概念的角度，描述了整个系统要实现的功能。作为一种架构视图，本人把这部分内容放到《细化架构阶段-业务架构》部分，以便提供一个完整的架构视图。

#### 4.2.1  关键约束

1. 采用Java语言；

2. 采用行方自主研发的Tesla平台作为基础开发平台；

3. 采用分布式服务设计风格；

4. 前期（一期、二期）应用运行在集群环境，后期迁移到基于Docker的云服务平台；

5. 前期（一期、二期）数据运行在关系数据库环境，暂时不用考虑分库分表，后期随着业务量的增加，必须考虑分库分表；

6. 项目周期：

   一期：2017年3月1日至2017年7月31日，主要完成基于Tesla平台的分行特色业务云平台的搭建工作，含部分通用公共组件；

   二期：2017年8月1日至2017年12月31日，主要完成分行特色业务云平台通用技术组件、业务组件、业务服务的开发、与不少于6个分行进行业务对接等；

   三期：2018年1月1日至2018年5月31日，分行特色业务云平台分库分表、云服务平台迁移、业务对接等；

#### 4.2.2  关键质量

##### 4.2.2.1  性能

系统必须满足预期的性能目标，在并发用户数（Concurrent Users）、并发事务数（Transactions per Second，TPS）、响应时间、吞吐量（Throughout）等指标方面达到预估值，支撑使用人群的正常使用操作。

分行特色业务云平台预期的性能指标如下：（非集群环境）

1. 并发用户数：200。

2. 并发事务数：300。

3. 平均响应时间：100ms。

##### 4.2.2.2  可用性

可用性是指系统在指定时间内提供服务有效访问的特性。

分行特色业务云平台至少保证可用性是3个9，即软件具有较高可用性，也就是说软件年度不可用时间小于9小时。

分行特色业务云平台要在以下几个方面支持系统的高可用性： 

1. 高可用的应用 

支持集群化部署：使用F5进行负载均衡，使用基于suce linux的X86虚拟机进行集群部署；

支持云化部署：允许分行特色业务云平台迁移到行方的私有云，该私有云基于Docker实现。

2. 高可用的服务

   服务降级熔断：当外部系统不可用或连续出现结果异常时，应可达到服务降级的效果，全熔断或部分熔断异常服务容量，保证正常服务的可用性，防止出现雪崩效应。

   服务流量控制：对某一特定服务提供并发量控制，通过修改参数配置可调整服务并发数量。

   服务对象权重控制：提供对不同服务对象（模块）的流量权重控制，通过修改参数配置可调整对不同服务对象提供服务的权重比例。

   服务开关：单个服务动态开关，系统整体状态动态开关。

   集群服务流量控制：	针对于一个特定服务提供集群并发量控制，通过修改参数配置可调整服务并发数量。该功能推出后，可替换单实例流控的方式。

   客户化并发控制：针对某一特定服务，解析接入报文数据后，对指定数据项匹配后做并发控制，如：针对某一商户进行单独并发控制。

3. 高可用的数据

支持总行数据库DB2的高可用。

对于分行数据库的高可用性，由分行自己实现。

4. 高可用的软件质量保证

代码：对代码版本进行控制。

测试：支持自动化测试。

服务灰度发布：对外服务变更时，做到对分行特色应用的透明，在验证周期内，保证对非验证分行应用不受影响，使得服务变更对分行特色应用造成的影响最低。

5. 运行监控

进程/服务监控：对本地服务、进程繁忙情况提供监控界面，供系统负责人进行监控。

实时交易：对实时交易基本要素进行监控：交易金额、成功情况、耗时、渠道、客户信息等提供实时监控。

对流程编排过程的监控。

监控预警：设置告警级别，告警方式，告警规则，告警活动。

告警级别：自定义，页面显示，默认告警方式不同；

告警方式：邮件，短信，页面展示；

告警规则：该条告警执行的操作（如取连续3笔后台响应超时的交易），针对一个告警规则，指定告警级别及告警方式；

##### 4.2.2.3  伸缩性

伸缩性指不需要改变软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或缩小软件的服务处理能力。

分行特色业务云平台需要支持多台服务器构成集群，并且加入新的服务器后可以提供和原来的服务器无差别的服务。

##### 4.2.2.4  扩展性

扩展性指在对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。

分行特色业务云平台需要具备良好的扩展性，能在系统基础设施稳定不需要经常改变的情况下，对需求变更可以敏捷响应。

##### 4.2.2.5  安全性

安全性指保护系统不受恶意访问和攻击，保护重要数据不被窃取。

分行特色业务云平台需要保证总分之间、第三方与总行、分行之间通讯安全，保证敏感的数据不外泄。

1. 通讯安全

   标准加解密功能：使用总行标准安全加解密方法提供给分行使用。

   标准加验签功能：使用总行标准安全加验签方法提供给分行使用。

2. 数据安全

   日志脱敏功能：实现关键敏感字的日志脱敏功能。

   加密存储功能：FTP密码明文存储、数据库密码明文存储修改为加密存储。

#### 4.2.3  关键功能

##### 4.2.3.1  公共技术功能

1. 服务编排

使用Tesla的服务编排组件，进行复杂流程服务（涉及两个及其以上服务调用、以及需异常处理的服务）的封装。

2. 基于Dubbo的服务调用

基于Tesla3.0的服务调用方式，实现服务位置的透明发现，软负载调用，服务超时设置，并发控制等功能。

服务权限管控等功能目前重点通过平台数据库控制机制实现，注册中心上的管控方式依赖于注册中心的可用性，仅作为辅助控制方法。

3. 公共联机处理框架

 实现公共的联机处理框架，提供通用的服务接入处理，包括入参预处理、初始化交易流水、更新交易流水、出参预处理等功能，对服务调用透明化，简化业务开发。

4. 统一渠道接入能力

 通过API网关，接入总行公共渠道，在网关上实现通讯协议解析，安全认证，流量控制，数据转换，协议转换等功能。

5. 统一消息通知

 服务通过配置化实现交易前、交易成功、交易失败、交易异常的消息通知机制，调用消息通知组件，与联机服务框架解耦。通知的方式可扩展，通知失败后的处理规则可选择。优先实现短信方式。

6. 统一异常处理

服务通过配置化实现异常处理的自动处理，当异常处理到达最大重试上限后，将异常处理信息推送异常处理平台。同时，支持异常处理平台回调平台服务的实现。

7. 异步任务调度

支持非持久化异步任务调度和持久化异步任务调度。

8. 本地缓存

实现基于本地内存的缓存组件，缓存运行过程中极少变更的配置数据和业务数据。除此之外，本地缓存组件需要实现如下功能：

实现缓存查询服务、缓存更新服务（远程服务、本地服务）等缓存管理功能；

基于Zookeeper的Watch机制，实现了集群环境中，缓存更新事件的发布与订阅，以支持该组件在集群环境中的使用；

为了保证集群各节点缓存都进行了更新，在控制台增加了相应缓存查看，缓存更新功能，便于应用实例与ZK之间出现通讯异常时，缓存仍然能正常更新；

同时支持基于ZK的自动更新和基于控制台的手动更新，各应用根据实际情况配置；

同时支持应用级本地数据缓存和模块级本地数据缓存，各自管理，互不冲突；

9. 自动任务调度

实现自动任务调度组件，以支持平台任务的定时调度，具体功能如下：

- 支持Tesla平台Function功能的跨模块调用；

- 支持任务持久化；

- 支持集群和分布式任务；

- 分线程池管理；

- 任务调度定义可配置化管理；


10. 总分报文通讯组件

实现公共的报文通讯组件，供分行调用总行的服务，对分行屏蔽报文协议解析封装、压缩解压、签名验签功能。另外，提供灵活的扩展机制，供后续功能的扩展。

11. 公共文件处理组件

实现文件配置化的组装、解析功能。

12. 总分文件交互组件

分平台与总平台或后台公共模块文件交互的方案实现，使用公共组件，使分行对总分文件交互方式做到透明化。

13. 全局序列号发生器

 实现数据库存储全局序列号，应用启动时加载流水号段。

14. 分布式集群文件配置

 使用Tesla现有的配置管理中心能力实现，用于分布式应用的集群技术参数的配置。同时，配置的修改有历史记录可追踪，提供审计信息查看功能；

15. 公共返回码管理

 实现基于数据库的公共返回码管理，便于全平台的返回码资源共享，便于查看，维护。支持启动时加载数据库内容至本地缓存，支持动态刷新。

16. 分库分表

 应对大交易量交易对数据库单表造成的操作压力，支持进行分库分表操作，对表进行水平拆分和纵向拆分。

17. 数据归档组件

 应用系统对于长时间运行后，某些记录数过大（存量/增量指标）的表，且不需要提供实时查询的数据，应提供归档机制，直至满足监管和行内要求的最低保留时限，以避免数据无限增长对系统容量和运行效率造成负面影响。归档数据可考虑备份至本系统历史库，也可考虑归档至历史归档平台。

18. 文件归档组件：

 对于不需要长期保留的文件，如对账文件，产品信息文件等，需要提供定时清理机制，系统应可配置保留天数，超过天数（建议7天）的文件自动清理。

对交易日志文件，实现自动定期备份、归档和清理，避免因文件数量过多导致应用处理效率低下。对接ELK或日志归档平台进行备份后，自动清理。

19. 标准通讯SDK

供接入商户使用，集成加解密、数字签名等安全功能，通讯协议拆解包等通讯功能，统一接入标准，简化商户接入难度。

20. 公共批处理框架

实现批处理框架，以支持大量作业的并发处理、并发控制、异常处理等，具体要求如下：

- 互斥控制：
  - 1) 互斥作业应有防止并发控制机制；
  - 2) 单个批处理应控制并发重复执行；
  - 3) 前后依赖关系的批处理应保证顺序执行；

- 并发控制：对大数据量（量化）批处理应可实现并发处理，通过多线程/进程或数据库层实现并发，并发数可动态调整；


- 断点执行：单个批处理处理过程中失败，修复问题后应支持断点处继续执行；


- 紧急跳过：对于无法短时间修复的批处理，能提供紧急跳过该步骤，继续后续批处理功能；

- 通知机制：批处理开始、结束、异常等情况，可通过邮件和短信通知相关人员；


- CPS调度：批作业应支持CPS系统调度发起交易和本地管理端发起交易。对处理失败的批处理，可通过本地管理端再次发起该作业；

- 异常业务数据通知：对批处理过程中遇到不影响继续处理，但存在异常或可疑的数据，产生工作流任务或实时通知业务人员进行异步处理；

- 定时任务自定义：系统提供自定义的定时自动任务，完成经常调整的定时任务，不建议通过系统的crontab定义自动任务。与其他系统有关联的作业，不建议使用此方式；

- 与联机交易冲突：
  - 1)	批处理过程应尽量减少联机（计划内）的可用性；
  - 2)	考虑资源（数据库资源/网络资源/进程资源等）不影响联机交易的可用性；

- 作业监控：对批作业状态及进度提供展示界面；

##### 4.2.3.2  公共业务功能

1. 应用日终组件

完成平台通用的修改平台状态、切日前任务处理，切日任务，切日后任务处理功能。同时，支持多个切日前任务的依赖关系、多个切日后任务的依赖关系分别可配置，根据依赖关系顺序执行。

2. 日终对账组件

对分平台提供公共的日终对账能力，从支付平台按商户获取商户对账单文件，商户手续费文件。

3. 额度控制组件

实现额度控制组件，支持通过配置化的数据项，控制指定交易的额度占用及释放。可按照数据级的颗粒度进行配置，如控制某个商户发起的指定交易额度控制规则。

 在后端有额度控制功能前提下，可不进行配置，避免性能损耗。

4. 频度控制组件

 实现频度控制组件，支持通过配置化的数据项，控制指定交易的频度占用及释放。可按照数据级的颗粒度进行配置。如控制某个商户发起的指定交易频度控制规则。

在后端有频度控制功能前提下，可不进行配置，避免性能损耗。

5. 通用黑白名单控制组件

通过配置的数据项，从指定的上下文中根据key=value的组合找出控制主键，并且对该主键进行黑名单准入或白名单准入功能。

##### 4.2.3.3  基本服务封装

1. PE-支付引擎

封装总行支付引擎提供的通用支付相关的服务，预计17个，根据后期具体业务需求而定。

2. UNPS-统一网络支付系统

 封装统一网络支付系统提供的在线支付相关的服务，预计27个，根据后期具体业务需求而定。

3. NPS-网络支付系统

 封装网络支付系统提供的在线支付相关的服务，预计2个，根据后期具体业务需求而定。

4. RLS-零售贷款系统

 封装零售贷款系统提供的贷款相关的服务，预计5个，根据后期具体业务需求而定。

5. 移动支付收单系统

 封装移动支付收单系统提供的移动支付相关的服务，预计5个，根据后期具体业务需求而定。

##### 4.2.3.4  流程服务封装

1. 支付结算服务封装

封装支付结算类的服务接口，包括通用的支付结算接口、招标通的服务接口、见证支付的服务接口、订单支付的服务接口等。

2. 信息查询服务

 封装支付/退款结果查询、交易结果查询、商户提现/余额查询等服务。

3. 辅助服务

 封装一些通用功能服务，如总分文件传输服务等。

### 4.3  概念架构阶段

在概念架构阶段，针对已经分析出的重大需求、特色需求、高风险需求，必须有针对性地确定解决方案，从而使系统提供的各种功能可以满足用户的需求。

在概念架构设计过程中，可以采用以下几步：

1. 首先，针对每个关键需求，确定相应的解决方案，规划对应的系统、子系统或功能模块；

2. 其次，对系统、子系统或功能模块进行分层设计。在此，引入分层概念，如：

逻辑层：重视职责的划分，职责之间通常是上层使用下层的关系，不关心上层和下层是否“能分布”在不同的机器上；

物理层：指能分布在不同机器上的软件单元，不同物理层之间必须跨机器访问。

按通用性分层：将通用性不同的部分划分到不同的层，以此作为系统的总体切分方式。

3. 最后，采用“目标-场景-决策”表，质疑非功能需求，验证现有架构是否满足。如果不能满足，则调整架构。

“目标-场景-决策”表如下图所示：

![img](微服务架构设计实践.assets/20180407152825594)

####  4.3.1  概念性架构-全行体系视角

在确定了分行特色业务云平台关键需求以后，为了让开发人员对分行特色业务云平台在全行应用体系中所处的位置和角色有个清晰的了解，建议通过一张图展示分行特色业务云平台在全行应用体系中所处于的位置和所扮演的角色，如下图所示：

![img](微服务架构设计实践.assets/20180407152908394)


1.	分行特色业务云平台总平台-服务融合中心

发挥总行大前置的作用，对分平台提供公共产品服务能力，并且在此基础上实现全行服务集中管控，隔离调用方与产品方的技术风险。

2.	分行特色业务云平台分平台-特色业务分平台

在公共的特色业务开发框架内，使用标准化技术组件、业务组件，进行分行特色业务创新。

#### 4.3.2  概念性架构-平台体系视角

确定了分行特色业务云平台在全行应用体系中所处于的位置以后，接下来就需要针对影响软件架构的重大需求、特色需求、高风险需求，有针对性地确定解决方案。

分行特色业务云平台概念性架构图如下所示：

![img](微服务架构设计实践.assets/20180407153052440)

1. 分行特色业务云平台-基础开发平台（BCAP）

基础开发平台（BCAP）是基于Tesla技术平台开发的业务平台，作为分行特色业务云平台的基础开发平台，对总行和分行提供两种能力：技术能力和业务能力。通过这两种能力，实现开发敏捷和业务敏捷。

公共技术组件提供通用的技术能力，主要包括：

- 联机服务框架；

- 定时任务调度；

- 总分通讯机制；

- 公共异常处理；

- 批处理框架；

- 消息通知；

- 服务编排；

- 本地缓存；

- 全局序列号生成器；

- API网关；

- 总分文件交互组件；


公共业务组件提供常用的业务能力，主要包括：

- 应用日终；

- 日终对账；

- 额度控制；

- 频度控制；

- 黑白名单；


2. 分行特色业务云平台-服务融合中心（SCC）

服务融合中心是分行特色业务云平台中的总平台，位于总行，对外以服务的方式提供业务功能；

3. 分行特色业务云平台-特色业务分平台（JCAP）

特色业务分平台是各分行根据自己的特色业务需求，基于分行特色业务云平台提供的基础开发平台进行开发的特色业务应用。

4. 支撑系统

控制台：为开发人员提供系统管理、参数配置等功能，为系统管理人员、运维人员提供日志级别调整功能、缓存更新、查看功能、任务调度管理功能、异常任务查询功能等。

监控中心：收集应用发送过来的数据，然后进行统计、分析，并以图形页面的方式提供给运维人员查看。

服务管理平台：提供服务注册、发现、订阅、服务开关、服务限流、服务降级、服务权重调整功能。

特色业务开放平台：为分行开发人员提供工程创建、资源下载、接口测试、开发工具下载等功能。

5. 开发规范

制定分行特色业务云平台的一系列开发规范，指导开发人员进行软件开发。

6. 过程管理

通过一系列的过程管理，保证软件的持续交付的质量。

### 4.4  细化架构阶段

#### 4.4.1  业务架构

##### 4.4.1.1  业务架构定义

业务架构定义了软件的业务能力，从概念层面帮助开发人员理解系统。

在业务架构中，动态的内容包括业务流程、节点、输入输出，静态的内容包括业务域、业务模块、单据模型等。

##### 4.4.1.2  业务架构设计原则

业务架构设计过程中，主要从以下四个方面考虑：

![img](微服务架构设计实践.assets/2018040715382757)

##### 4.4.1.3  业务架构实践

笔者认为，业务架构设计应该在架构准备阶段完成，主要根据用户的需求，从业务概念的角度描述系统，帮助开发人员理解系统。

在此处描述业务架构视图，主要是想给大家一个完整的视图体系。

在进行业务架构设计过程中，一定要通过业务术语，从用户的角度描述整个系统能为用户做什么，能给用户提供什么样的产品、功能或服务。

分行特色业务云平台的业务架构视图如下所示：

![img](微服务架构设计实践.assets/20180407153915835)


分行特色业务云平台，旨在为分行应用提供全面、易用、统一、安全、可靠的服务能力，包括业务能力和技术能力，降低对于总行产品模块的接入难度，整体控制接入风险，同时整合、集成总行服务能力。

**一、总行特色业务服务中心**

总行特色业务服务中心在本次分行特色业务云平台中定位是对分行特色业务提供各种总行后台系统的服务能力，包括业务能力和技术能力，并且对分行特色业务的接入做到统一管理和差异化控制功能。

1. 业务能力：

总行特色业务服务中心通过为各分行提供适合分行特色业务需求的业务流程服务，简化了业务接入难度，加快了业务接入速度，可以快速适应市场需求的变化，按需业务流程定制，实现了业务敏捷性。

总行特色业务服务中心提供的业务能力主要通过原子服务和流程服务来实现，具体如下：

- 原子服务：首先，针对总行核心业务各个后台系统（PE、RLS、UNPS、NPS、移动支付手段或其他产品）提供的各种基本业务服务进行封装，封装成符合分行特色业务云平台技术规范的原子服务，这些原子服务为上层流程服务提供基本的业务功能，可以在各个流程服务中复用；

- 流程服务：然后，按照分行特色业务应用的业务产品需求进行服务流程的融合，重新编排，对外暴露更适合消费者，更容易让消费者理解，且安全可靠的API服务能力。根据目前分行使用最多的业务服务进行统计，计划先建设需求最多的四类服务中心：支付结算服务中心、信息查询服务中心、贷款服务中心和辅助服务中心；


2. 技术能力

总行特色业务服务中心通过为各分行提供一套Java开发框架，以及一组通用的技术组件和业务组件，减少开发人员的开发难度，加快了开发速度，提高了开发质量，规范了开发技术，实现了开发敏捷性。

总行特色业务服务中心提供的技术能力主要通过技术组件和业务组件来实现，具体如下：

- 技术组件：根据特色业务开发需求，定制开发适用总行和分行的通用技术组件，实现组件复用，避免重复造轮子；

- 业务组件：根据特色业务业务需求，定制开发适用总行和分行的通用业务组件，提供通用的日终功能、风控功能、服务安全访问控制功能等；


**二、分行特色业务应用**

各分行根据本地特色业务的需求，采用总行提供的开发框架（包括技术组件和业务组件），基于总行服务融合中心提供的各种服务，快速、灵活地开展各自特色业务，如南宁贷款业务、深圳发薪日贷业务等。

**三、API网关**

API网关定义了请求接收、请求管控和请求响应的基础接口和配置，支持多种协议的接入、接出以及协议的透明转换功能。另外，根据不同的配置，进行各种不同的管控功能。

API网关为分行特色业务应用接入总行服务融合中心提供了统一的渠道接入能力。通过API网关，接入总行公共渠道，在网关上实现通讯协议解析，安全认证，流量控制，数据转换，协议转换等功能。

**四、其它支撑系统**

为分行特色业务云平台提供分行框架快速搭建、分行特色业务快速开发、测试、部署、发布、运营管理、运维监控等功能，主要包括控制台、监控中心、服务注册中心、服务管理平台、特色业务开放平台等。

#### 4.4.2  数据架构

##### 4.4.2.1  数据架构定义

数据架构定义了用来支持业务的各种数据，以及他们之间的关系。

数据架构着重考虑“数据需求”，关注点是持久化数据的组织。

在数据架构设计过程中，主要涉及三部分内容：数据定义、数据分布与数据管理：

1. 数据定义，是数据架构规划中最重要内容。定义良好的数据模型，包括数据概念模型、数据逻辑模型、数据物理模型，以及更细化的数据标准，可以反映业务模式的本质，确保数据架构为业务需求提供全面、一致、完整的高质量数据，且为划分应用系统边界，明确数据引用关系，定义应用系统间的集成接口，提供分析依据。良好的数据模型与数据标准的制定才是实现数据共享、保证一致性、完整性与准确性的基础。有了这一基础，企事业单位才能通过信息系统应用逐步深入，最终实现基于数据的管理决策。

2. 数据分布，一方面是分析数据的业务，即分析数据在业务各环节的创建、引用、修改或删除的关系；另一方面是分析数据在单一应用系统中的数据结构与应用系统各功能模块间的引用关系，分析数据在多个系统间的引用关系。数据业务分布是数据系统分布的基础。对于一个拥有众多分支机构的大型企事业，数据存储模式也是数据分布中一项重要内容。从地域的角度看，数据分布有数据集中存储和数据分布存储两种模式。数据集中存储是指数据集中存放于企事业总部数据中心，其分支机构不放置和维护数据；数据分布式存储是指数据分布存放于企事业总部和分支机构，分支机构需要维护管理本分支机构的数据。这两种数据分布模式各有其优缺点，企事业应综合考虑自身需求，确定自己的数据分布策略。

3. 数据管理，一方面要制定贯穿企事业数据生命周期的各项管理制度，包括：数据模型与数据标准管理，数据分布管理，数据质量管理，数据安全管理等制度；另一方面应该确定数据管理组织或岗位。

数据架构规划是进行企事业IT架构规划不能绕开的重要环节，对于完全通过定制化开发进行应用系统实施的企事业单位来说，数据架构设计是完全可以指导应用系统开发的。

数据架构规划的目的有三个：

1. 分析业务运作模式的本质，为未来核心应用系统的确定以及分析不同应用系统间的集成关系提供依据。

2. 通过分析核心数据与业务之间的应用关系，分析规划应用系统间的集成关系。

3. 数据管理的需要，明确企事业的核心业务数据，这些数据是应用系统实施与运行时IT系统实施人员或管理人员应该重点关注的，要时时考虑保证这些数据在整个企事业层面的一致性、完整性与准确性。

##### 4.4.2.2  数据架构设计原则

在数据架构设计过程中，应该考虑如下因素：

  ![img](微服务架构设计实践.assets/20180407154619193)

##### 4.4.2.3  数据架构实践

###### 4.4.2.3.1  数据定义

**一、概念数据模型**

根据业务需求，分析业务过程中涉及到的所有业务实体，抽取出满足用户场景的实体对象，以及它们之间的关联关系。

在概念建模阶段，主要做三件事：

1. 客户交流。

2. 理解需求。

3. 形成实体。

这是一个迭代，如果先有需求，尽量去理解需求，明白当前项目需要完成什么，不明白或者不确定的地方和客户及时交流，和客户二次确认过的需求，落实到实体。如果没有，则通过先和客户交流，进而将交流结果落实到需求，之后进一步具体到实体。

分行特色业务云平台数据概念模型-基本配置管理部分如下：

![img](微服务架构设计实践.assets/20180407154723883)

1. 系统管理类

该部分主要包括系统管理类对象。由于采用基于角色的权限管理，所以涉及的对象主要有用户、角色、功能。

2. 基础数据类

该部分主要是各种参数配置对象和流水的统一基础数据属性信息，包括：服务场景类型，业务领域，业务区域，机构信息等，后续可根据服务类型的扩展增加相应基础数据对象。

其中，服务场景类型，业务领域和业务区域后续在控制及事后监控中控制风险使用，例如：通过定义不同的服务场景，来形成各服务场景调用内联服务的风险级别，配置不同的风险控制策略，并且在监控时进行区分关注。

3. 特色应用类：

该部分主要包括特色业务应用组织、特色业务应用，特色业务产品信息、特色业务合作方信息以及使用业务服务的应用服务场景信息。这些对象用来管理各分行实现的特色业务应用，应用上实现的业务产品以及该业务产品归属的合作方信息，并且通过配置这些应用使用服务融合中心上业务服务的场景（服务场景）来差异化的控制调用服务时的数据属性以及业务风险。

4. 业务服务类：

业务服务：管理服务融合中心对外发布的业务服务信息。

业务服务原子服务映射规则：对业务服务与平台内部原子服务调用关系进行管理授权。

5. 原子服务类：

原子服务：管理由服务融合中心封装的原子服务信息，这些原子服务不直接对外调用，供流程服务调用。原子服务可实现本地的原子服务功能以及后台模块的原子服务功能，针对于后台服务的原子服务一对一的进行封装。

模块信息：管理服务融合中心原子服务的归属模块，对于服务融合中心封装的远程原子服务，在该表中注册远程服务的归属模块（如PE，NPS），对于本地封装的原子服务，在该表中注册本地模块。

6. 通用功能类：

通用扩展属性：用来存储各个对象（如业务服务，服务场景等）扩展属性，通过对象类型+对象编码+控制规则主键匹配一组规则。

对象营业时间：用来存储各对象的营业时间属性。如（特色业务应用、特色业务、特色业务合作方、服务场景、业务服务、原子服务）。

分行特色业务云平台数据概念模型-流水部分如下：

![img](微服务架构设计实践.assets/20180407154901593)


流水表主要分成基础类流水表和业务类流水表。

1. 基础类流水表：

接入流水表主要负责当外模块调用服务中心业务服务时，统一记录服务流水。

接出流水表主要负责当服务中心业务服务调用外部模块时，登记接出流水，记录与外部模块的交互情况。

2. 业务类流水：
   目前主要先使用账务流水表，登记账务类流水的信息，后续可根据实际业务类型，扩展不同的业务流水表。

上述概念数据模型定义了特色业务云平台核心部分的实体对象及它们之间的关系。后续随着功能的完善，业务的增加，需要继续完善概念数据模型。 

**二、逻辑数据模型**

概念数据模型完成以后，需要进一步对实体对象进行细化，细化成具体的表，同时丰富表结构。

根据需求确定具体需要哪些表，以及每张表的属性。此时会涉及主键的选取，外键的关联，约束的设置等细节。笔者认为只要能把每个实体属性落实下来就是很不错了，因为随着项目的开展，很多表的列都会有相应的改动。

这个阶段的产物是，可以在数据库中生成的具体表及其他数据库对象，包括主键，外键，属性列，索引，约束甚至是视图以及存储过程。

以下为服务融合中心部分逻辑数据模型，以供参考。

1. 系统管理部分逻辑数据模型：

![img](微服务架构设计实践.assets/20180407155207950)

2. 基本配置部分逻辑数据模型：

服务配置部分： 

![img](微服务架构设计实践.assets/20180407155248579)

业务产品配置部分： 

![img](微服务架构设计实践.assets/20180407155306502)

其它配置部分：

![img](微服务架构设计实践.assets/20180407155323157)

3. 流水部分逻辑数据模型：

 ![img](微服务架构设计实践.assets/2018040715540494)

 **三、物理数据模型**

物理建模可以将在逻辑建模阶段创建的各种数据库对象生成为相应的SQL代码，运行来创建相应具体数据库对象。

这个阶段我们不仅仅创建数据库对象，针对业务需求，我们也可能做如数据拆分（水平或垂直拆分）、读写分离。

根据所选数据库管理系统的类型，生成相关的SQL语句，然后创建具体的数据库对象。

例如：业务区域表在MySQL数据库的创建语句：

```sql
CREATE TABLE `t_busi_area_info` (
  `busi_area` VARCHAR(10) COLLATE utf8_bin NOT NULL COMMENT '区域编码',
  `area_name` VARCHAR(60) COLLATE utf8_bin NOT NULL COMMENT '业务领域名称',
  `area_level` CHAR(1) COLLATE utf8_bin NOT NULL COMMENT '区域层级',
  `parent_area` CHAR(6) COLLATE utf8_bin NOT NULL COMMENT '上级区域编码',
  `branch_no` CHAR(4) COLLATE utf8_bin DEFAULT NULL COMMENT '分行机构号',
  `status` CHAR(1) COLLATE utf8_bin NOT NULL DEFAULT '1' COMMENT '状态',
  `memo` VARCHAR(255) COLLATE utf8_bin DEFAULT NULL COMMENT '备注',
  `dac` CHAR(16) COLLATE utf8_bin DEFAULT NULL COMMENT 'dac校验',
  PRIMARY KEY (`busi_area`),
  KEY `t_busi_area_info_IDX0` (`area_name`)
) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='业务区域表';
```

**四、数据字典**

在数据建模过程中，基于对需求的理解，会抽取出部分业务规则，这些信息将会成为数据字典中非常重要的部分，即元数据。

以下是数据字典的部分内容，以作参考：

1. 服务功能类型

以服务的业务功能领域来定义数据规则，目的是为了统一规范服务的业务领域编码规范，后续可通过该编码对相同功能的服务进行统一管理、统计。

两位编码表示一个类型含义，最多能表示15个层次的类型含义。

功能类型按照从粗到细的原则进行编排，下级功能领域含义需要与上级功能领域含义一致。

一级功能领域目前定义如下：

![img](微服务架构设计实践.assets/20180407160754790)

各一级功能领域内的二级功能领域编码定义如下：

![img](微服务架构设计实践.assets/20180407160832327)

![img](微服务架构设计实践.assets/20180407160919457)

2. 业务领域

![img](微服务架构设计实践.assets/20180407161022650)

![img](微服务架构设计实践.assets/20180407161141500)

###### 4.4.2.3.2  数据存储

**一、数据库管理系统**

在总行，数据库管理系统采用DB2，版本建议为10.5及以上。

在总行，由于数据库管理系统采用DB2，所以数据库高可用性通过DB2 数据库产品所提供的多种高可用性策略的功能来实现，具体如下：

1. DB2 高可用性功能部件-HA：支持IBM DB2服务器和集群管理软件相集成。

2. DB2 数据服务器高可用性灾难恢复功能-HADR：一种数据库复制功能，它提供针对部分站点故障和整个站点故障的高可用性解决方案。HADR 通过将数据更改从源数据库（称为主数据库）复制到目标数据库（称为备用数据库）来防止数据丢失。

3. DB2日志镜像：支持数据库级别的日志镜像。

4. DB2故障监视器工具：该工具通过监视 DB2 数据库管理器实例并重新启动任何过早退出的实例来使 DB2 数据库正常运行。

在分行，根据每个分行各自的需求，从DB2 10.5及以上、Oracle11g及以上、MySQL5.5及以上三种数据库管理系统中任选其一。 

在分行，根据所选的数据库管理系统，采用相应的产品和工具实现数据库高可用性。

###### 4.4.2.3.3  数据分布

根据系统数据产生、使用、管理等方面的不同特点，采用不同的数据分布式存储和处理手段。

数据分布策略的3条应用原则：

1. 合适原则：合适的才是最好的。把握系统特点，确定分布策略。

2. 综合原则：当系统比较复杂时，其数据产生、使用、管理等方面可能很难表现出压倒性的特点，此时，就需要考虑综合运用不同的数据分布策略。

3. 优化原则：当难以“一步到位”地作出数据分布策略的正确选择，以及还存在质疑时，应从“对吗”、“好吗”两个方面进行对比、评估、优化。

由于项目时间紧，人员紧缺，总行科技其它相关项目组进度方面的影响，以及其它一些行方政策上约束，所以在项目第一、二阶段，服务融合中心支持两种应用部署方式：

**一、集中模式+复制模式+子表模式**

在项目第一、二阶段，主要进行服务融合中心基础开发框架、公共技术组件、公共业务组件的开发、测试。此时，总行服务融合中心提供的服务以对总行核心系统提供的服务进行服务封装为主，业务数据存储在总行核心系统中，不在服务融合中心存储。

另外，总行服务融合中心接入的分行业务有限，业务访问量较低，每天产生的流水类数据量较少。

基于上述原因，建议服务融合中心作为单一应用部署，采用集群部署实现水平扩展，支持大并发访问，实现高可用性。

在数据库方面，同样采用单一库部署，通过读写分离、一写多读、内存缓存的方式保证读操作的性能和高可靠。

单一应用集群模式如下图所示：

![img](微服务架构设计实践.assets/20180407161415951)


在上述部署模式下，数据分布模式如下：

1. 服务融合中心中系统管理类、基本配置类数据，此类数据属于配置型数据，读写比大（即读多，写少），强依赖读，弱依赖写，不要求严格的读一致性，读可靠性要求高。对于这类数据，采用集中式管理。另外，通过读写分离、一写多读、分布式缓存、内存缓存的方式保证读操作的性能和高可靠。

2. 服务融合中心中流水类数据，属于流水型数据，此类数据读写比小（即读少、写多），不断产生新的数据，各条数据间是独立的。单条数据的更新需要保证强一致性。流水型数据很方便做水平扩展。对于流水类数据，由于处于刚投产阶段，接入的分行特色业务数量有限，所以暂时采用集中模式和子集模式。

3. 为每张流水类数据的表建立一个副本表（数据结构与主表一致），这样流水类数据的主表只存储热点数据，即指定维度内的数据（如按照时间维度：1个月以内、1个季度以内等，或按其它业务维度），而其它数据保存在副本表内。这样针对主表、副本表分别进行优化（如：支持大量写操作的主表减少索引，以读为主的副本表可以根据查询需求设置多个索引）。

**二、集中模式+复制模式+子表模式+独立Schema 模式**

如果在项目第一、二阶段需要实现的本地业务服务较多，接入的分行业务较多，建议把服务融合中心中的流程服务按照业务域分组，每组单独集群部署。

分布式应用集群部署模式如下图所示：

![img](微服务架构设计实践.assets/20180407161524685)


在这种部署模式下，数据分布模式调整为：

1. 把单一数据库拆分为一个通用的基本配置管理库和多个应用业务库（一个应用对应于一个业务库）。

2. 通用基本配置管理库主要包括系统管理类、基本配置类、流水类数据，数据分布模式同单一应用集群模式。

3. 应用业务库主要包括该应用所需的业务相关数据，数据分布模式采用独立Schema模式，即每个应用采用单独数据库Schema的方式管理每个应用涉及的业务数据。

4. 每个应用涉及的业务数据，大部分属于状态型数据，读写比相当，必须保证可写才有意义，每一次写操作必须基于前一个正确的状态。针对关键业务的状态型数据，应尽量把维度拆细，一是提高并发处理能力，二是方便隔离故障影响。

5. 状态型数据要求严格的数据一致性。对于这类数据，除了阿里自主研发的基于 Paxos 协议的分布式强一致数据库（对于单节点故障，它提供 RPO=0，RTO<30 秒的容灾能力，致力于从数据库层屏蔽容灾细节，为应用层提供简单的使用方式）），暂时没有很好的完整解决方案。所以，这部分数据暂时采用单一数据库存储。

**三、集中模式+复制模式+分区模式**

随着接入的分行特色业务数量的增加，预计每天1亿笔交易量，导致流水相关表的数据量急剧增加。

在这种海量业务场景下，上述针对流水型数据的子表模式的数据库设计会遇到单表的容量瓶颈和单库的性能瓶颈。

针对这种情况，按照分布式的思想，对数据进行拆分，让集中在单点的读写访问分布到多个数据库服务器上，从而获得容量和性能上的弹性延伸能力。

常用的数据拆分模式：

- 垂直拆分：按业务域进行拆分；

- 水平拆分：按某个业务维度进行拆分，如用户、区间等；

- 读写拆分：读写分离；


为了支持灵活的数据分区，并且数据分区对应用层透明，分行特色业务云平台引入分布式数据访问组件ZDAL支持数据库拆分模式。在引入ZDAL组件以后，针对不同类型的数据采用不同的处理方式。

1. 配置型数据：涉及系统管理类表、基本配置类表

此类数据的特征是读多写少，数据量较小，采用群组模式。

群组（Group）模式，示意图如下：

![img](微服务架构设计实践.assets/20180407161726968)


采用该模式，一个主库，多个从库，主库负责写、从库负责读，在事务内的读也使用主库。

2. 流水型数据：涉及流水类表

对于流水类相关表，进行分库分表设计，采用切片模式。

切片（Shard）模式，示意图如下：

![img](微服务架构设计实践.assets/20180407161759363)


流水类表采用该模式，按照表中流水号ID进行拆分，根据逻辑切片与物理数据库、表的路由规则分布到据库中。

在本项目中，考虑到项目后期数据扩容方面的简易性、可维护性，建议采用如下数据库与表的拆分路由规则：

![img](微服务架构设计实践.assets/20180408172206293)

对按流水号ID进行切分的相关表水平切分为1024个逻辑分片，物理库为4个，逻辑分片按照分库分表规则分布在不同物理库中。1024个逻辑分片，逻辑分片与物理表一一对应，每个库256张表，每个表的顺序号都不相同，该模式下分库分表示意图如下：

![img](微服务架构设计实践.assets/20180407162401112)


如果扩容物理库到8台，则只需修改分库分表路由映射规则，之前四个库的后128张表分别迁移到新增的物理库中，同时调整逻辑数据库序号。该模式数据迁移相对方便，每次扩容时，每个库的表数量都在减少，扩容上限1024。

扩容后数据拆分示意图如下：

![img](微服务架构设计实践.assets/20180407162425525)


迁移过程需要一定时间，由于涉及到表数据的迁移和路由规则的切换，所以会影响一段时间数据服务的访问，迁移流程大致如下：

1. 停止对外提供服务，然后开始进行数据备份导出；

2. 进行表数据的迁移工作；

3. 修改ZDAL数据源配置文件，通过配置中心推送ZDAL动态加载；

4. 迁移验证，主要包括迁移数据完整性、数据路由是否正确，交易服务是否正常；

5. 验证无误后，删除原数据库中已迁移表；

6. 对外开始提供服务；


3. 状态型数据

针对本地服务业务库中的数据，如果某些业务表的数据量达到或超出特定数据库的单表限制，或单表数据量已经影响数据库读、写性能，则建议参考上述流水型数据，进行分库分表设计。

###### 4.4.2.3.4  数据管理

在数据管理方面，主要包括两个部分：

1. 制定贯穿整个数据生命周期的各项管理制度，包括：数据模型与数据标准管理，数据分布管理，数据质量管理，数据安全管理等制度。

2. 确定数据管理组织或岗位。

#### 4.4.3  应用架构

##### 4.4.3.1  应用架构定义

应用架构定义了系统由哪些应用组成，以及应用之间如何分工和合作。

应用作为独立可部署的单元，为系统划分了明确的边界，深刻影响系统功能组织、代码开发、部署和运维等各方面。

应用架构设计过程中，应用的分有两种方式：

1. 水平拆分，按照功能处理顺序划分应用，比如把系统分为web前端、中间服务、后台任务，这是面向业务深度的划分。

2. 垂直拆分，按照不同的业务类型划分应用，比如进销存系统可以划分为三个独立的应用，这是面向业务广度的划分。 

应用的合反映应用之间如何协作，共同完成复杂的业务，主要体现在应用之间的通讯机制和数据格式。通讯机制可以是同步调用/异步消息/共享DB访问等，数据格式可以是文本/XML/JSON/二进制等。

应用的分偏向于业务，反映业务架构，应用的合偏向于技术，影响技术架构。

在应用架构设计过程中，应用的分降低了业务复杂度，使系统更有序。应用的合增加了技术复杂度，系统更无序。

应用架构的本质是通过系统拆分，平衡业务和技术复杂性，保证系统形散神不散。

应用架构设计的初衷是为了减少应用程序之间的关系，让系统内部程序实现松耦合。

##### 4.4.3.2  应用架构设计原则

###### 4.4.3.2.1  架构分解原则

在系统分解过程中，可供参考的原则如下：

![img](微服务架构设计实践.assets/20180407163338919)

###### 4.4.3.2.2  架构依赖原则

在系统分解和组合过程中，可供参考的原则如下：

![img](微服务架构设计实践.assets/20180407163420895)

###### 4.4.3.2.3  服务设计原则

在服务设计过程中，应该遵循如下规则：

![img](微服务架构设计实践.assets/20180407163533643)


对于处于业务核心的基本服务（即原子服务），在设计过程中，还应该遵循如下规则：

![img](微服务架构设计实践.assets/20180407163609781)

##### 4.4.3.3  应用架构实践

在应用架构设计过程中，主要考虑如下内容：

1. 子系统划分：依据架构分解原则，对概念架构阶段设计的系统进行分解。

2. 接口定义：明确各子系统、各模块之间的接口定义；

3. 交互机制：明确各子系统、各模块之间的交互机制，如基于接口编程、消息机制或RPC调用等；

在进行应用架构设计时，应该根据系统的复杂性进行合理的拆分、组合，然后针对不同的部分，分别进行描述。

1. 对于简单的系统，如系统内部由少量的子系统、模块构成，并且与外围系统交互比较少，甚至无交互，则建议在一张应用架构视图上表现整体系统的组件、接口和交互机制。

2. 对于复杂的系统，如系统由多个子系统组成，每个子系统由多个模块组成，并且每个子系统单独开发、测试、部署，这些子系统之间通过某种交互机制进行通讯，协作完成指定的功能集，服务于用户。另外，这些子系统需要与其它已经存在的系统进行通讯。

    - 针对这样的系统，建议通过多张应用架构视图分别展示每个子系统的组件、接口和交互机制，以及该子系统与其它子系统的交互机制。此时，其它子系统以黑盒的方式存在，不必细化其内部组成。

    - 在每张应用架构视图内部，如果涉及的组件比较多，并且存在比较复杂的组件，如本地数据缓存组件、自动任务调度组件等。针对这样的组件，如果以黑盒的方式展示，比较笼统，对开发人员缺乏指导和限制的作用。如果以标准的应用架构图方式展示（组件、接口、交互机制），则会与所属的子系统的展示方式存在冲突，有些喧宾夺主的效果，导致主次不分，概念混乱。对于这种情况，建议在子系统内部以黑盒的方式展示组件，然后针对这些复杂的组件，单独使用一张应用架构视图展示组件的应用架构设计；

    - 对于子系统之间或子系统与其它系统的交互机制，如果简单、明确，则直接在应用架构视图中展示。如果比较复杂，则单独使用一张交互机制图进行补充说明；


###### 4.4.3.3.1  服务融合中心

分行特色业务云平台由多个系统构成，主要包括：特色业务总平台，即服务融合中心、特色业务分平台、控制台、监控中心、服务管理平台、特色业务开放平台、API网关等。其中每个系统又由多个子系统、模块、组件构成。针对这样比较复杂的系统，采用先整体、然后部分的多张应用架构视图进行展示，以最大限度地展示系统的组成，以及这些系统如何协作完成业务功能。

以服务融合中心为例，描述应用架构的设计过程：

1. 对整个应用先按照组件的通用性进行水平拆分，从下到上依次为：Tesla基础组件层、BCAP公共技术组件层、BCAP公共业务组件层、基础服务层、流程服务层、协议层；

2. Tesla基础组件层：由于采用Tesla平台提供的组件，只需要以黑盒的方式展示所需要的组件即可，无需细化每个组件。

3. BCAP公共技术组件层：这些技术组件需要根据具体的需求进行设计、开发、测试、集成。另外，某些组件实现比较复杂。所以，在整体的应用架构视图中以黑盒的方式展示，然后针对复杂的组件，分别使用单独的视图展示组件的应用架构设计。

4. BCAP公共服务组件层：同BCAP公共技术组件层。

5. 基础服务层：定义原子服务，实现服务复用。

    - 首先按照业务域进行垂直拆分，分为RLS（零售贷款系统）、UNPS（统一网络支付系统）、PE（支付引擎）等模块；

    - 这些模块可以集成部署在一个应用内，也可以按单个模块或几个模块的组合分别单独部署；

    - 对于每个模块进行水平拆分，如RLS，遵循按接口编程规范的分层设计，如业务接口层、业务实现层、数据访问接口层、数据访问实现层、远程服务调用；

    - 对于已经在总行核心业务系统中实现的服务，不进行二次开发，而是直接按照原子服务开发规范进行封装，在业务实现层通过Tesla平台提供的基于Dubbo客户端访问远程服务的功能调用远程服务；

    - 对于未在总行核心业务系统中实现的服务，按照业务需求进行二次开发；

    - 每个原子服务要独立完成一个完整的功能；

    - 对于参与到补偿型TCC分布式事务模型的原子服务，必须提供对应的冲正服务，用于业务补偿，抵消或部分抵消正向业务操作的业务结果，冲正服务满足幂等性；

    - 原子服务只供流程服务通过本地调用（即JVM内部调用）方式调用，不对外提供服务，即其它系统无法直接访问原子服务。原因：现阶段，联机服务处理框架只针对流程服务进行了接入封装，包括前置处理（初始化上下文、报文解压、验证签名、模块级个性化前处理、服务级个性化前处理、初始化接入流水等）、后置处理（服务级个性化后处理、模块级个性化后处理、更新接入流水、生成签名、压缩报文等）；后期建议联机服务处理框架可以直接对原子服务进行接入封装，这样原子服务按照规范直接对外提供服务；

    - 原子服务之间不能互相调用；


6. 聚合服务层：定义流程服务，实现业务功能。

    - 首先按照业务域进行垂直拆分，分为支付、贷款、信息查询辅助服务等模块；

    - 这些模块可以集成部署在一个应用内，也可以按单个模块或几个模块的组合分别单独部署；

    - 这些模块可以集群部署，实现水平扩展，以达到高性能、高可用性、可伸缩性；

    - 对于每个模块进行水平拆分，如支付，遵循按接口编程规范的分层设计，如业务接口层、业务实现层、数据访问接口层、数据访问实现层、本地服务调用；

    - 流程服务依赖原子服务。

    - 当流程服务只依赖一个原子服务，则在业务实现层通过Tesla平台提供的function-invoke，在JVM内部调用原子服务；

    - 当流程服务依赖2个及其以上个原子服务时，则通过服务编排框架进行服务编排；

    - 在流程服务层，采用补偿型TCC分布式事务模型实现服务层的分布式事务；

    - 流程服务通过Dubbo对外发布服务，至少支持HTTP/JSON、Webservice协议；

    - 流程服务之间可以相互调用；

7. 协议层：

    - 针对同一个服务接口，以不同的传输协议和传输的数据格式进行发布，如HTTP/JSON、Webservice、Hessian等，支持多种渠道接入；

    - 提供服务治理功能，如服务注册、发现、订阅机制，服务开关、服务降级、服务限流等功能；


8. 接口设计

在整个架构设计过程中，采用面向接口的编程方式，实现系统架构设计层面的开闭原则（对扩展开放，对修改关闭），当系统增加新功能时，不需要对现有系统的结构和代码进行修改。

按照上述设计过程进行拆分、整合以后，服务融合中心的应用架构视图如下所示： 

![img](微服务架构设计实践.assets/20180407164136754)

###### 4.4.3.3.2  服务融合中心内部及外部的调用关系

在整体应用架构视图中，由于涉及的系统、子系统、模块、组件比较多，只能简单地展示系统、子系统、模块之间的调用关系，不够直观。因此，增加了这个视图，详细地描述系统、子系统、模块之间的调用流程。

这个视图是可选的，根据具体情况确定是否需要此视图。

![img](微服务架构设计实践.assets/20180407164224910)

###### 4.4.3.3.3  本地数据缓存组件

针对比较复杂的技术组件、业务组件，可以进行组件级应用架构视图的设计工作。

在此以本地数据缓存组件为例。

本地数据缓存组件在本地内存中缓存运行过程中极少变动的配置数据和业务数据，以提高数据的访问速度，提高系统的高并发性。

在此基础上，增加缓存管理器、抽象的缓存实体对象、缺省的缓存实体对象、缓存更新服务（远程服务、本地服务）等功能，实现基于内存的本地数据的缓存管理功能。

另外，基于Zookeeper的Watch机制，实现集群环境中，缓存更新事件的发布与订阅，以支持该组件在集群环境中的使用。
本地数据缓存管理组件应该具有如下特性：

1. 缓存数据的预加载；

2. 缓存数据对应用透明；

3. 同时支持本地缓存更新服务、远程缓存更新服务；

4. 同时支持应用级和模块级本地缓存；

5. 支持通过ZK的Watch机制，实现缓存更新的监听与发布；

6. 支持多实例（集群）部署；

本地数据缓存组件的应用架构如下图所示：

![img](微服务架构设计实践.assets/20180407164335433)

1. 缓存管理器

缓存管理器主要负责缓存的存储、获取、更新、删除等；

2. ZK监控服务

基于Zookeeper的Watch机制，实现了集群环境中，缓存更新事件的发布与订阅，以及缓存通知的接收、处理，从而支持该组件在集群环境中的使用；

3. 消息处理器

基于阻塞队列实现的单线程消息处理器，解耦了ZK消息监控和ZK消息处理，最大限度地提高了ZK消息处理能力，提高了组件的可用性。

4. 缓存服务

提供本地和远程两种缓存更新服务。其中，本地缓存服务供应用内模块调用，远程缓存服务供控制台调用；

###### 4.4.3.3.4  自动任务调度组件

自动任务调度是指基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。

自动任务调度组件基于Tesla平台，使用已有开源框架Quartz（版本2.2.3），并结合Spring（版本4.2.0）实现对Tesla平台中各个模块提供的特定的Function任务的自动调度、运行，以及任务、计划的前端界面管理，具体要求如下：

1. 任务定义及实现：

由于服务融合中心基于Tesla3.0平台进行开发，并且支持模块单独热部署，所以要求各模块提供的任务必须以Tesla平台Function组件提供，不接受其它任何形式的任务，如普通的Java Bean任务、实现Quartz Job接口的任务、继承Spring QuartzJobBean类的任务等。

2. 任务管理功能：

为了方便管理人员维护任务，查看任务的执行状态、暂停或恢复任务的执行、修改任务的执行时间等，基于Quartz API实现相关的任务管理服务，并在服务融合中心提供管理界面，方便管理人员使用。任务管理服务主要包括：

- 获取任务列表（计划中的任务、运行中的任务）；

- 暂停任务；

- 恢复任务；

- 删除任务；

- 立即运行任务；

- 更新任务运行时间；


自动任务调度组件具有如下特性：

1. 支持Tesla平台Function功能的跨模块调用；

2. 支持分布式任务和本地任务同时使用一套数据库表；

3. 支持任务持久化；

4. 支持集群和分布式任务；

5. 良好的伸缩性；

6. 软负载均衡；

7. 高可用性；

自动任务调度组件的应用架构如下图示：

![img](微服务架构设计实践.assets/20180407164619450)

#### 4.4.4  技术架构

##### 4.4.4.1  技术架构定义

技术架构定义了实现整个系统所需的各种技术，包括开发类、过程管理类、运行环境类、运维支撑类、以及相关技术规范等。

更确切地说，技术架构描述了在一个可以独立部署的应用系统里，应用、应用平台、基础设施之间的关系。

在技术架构设计过程中，通常采用分层设计模式，把应用、平台、基础设施相对独立地拆分为以下几层：

1. 系统层，也叫基础设施层，包括系统级的硬件、软件两层：

    - 底层硬件包括主机、各种服务器、PC、存储设备、网络设备等；

    - 第二层系统软件包括各种操作系统、数据库等；


2. 平台层，通常包括两层，也可以混合成一层：

    - 下层是中间件或技术平台。中间件通常指的是厂家在系统层的基础上提供的平台软件，例如IBM的WebSphere、BEA的Tuxedo等；技术平台通常指的是用户自己开发的平台软件；

    - 第二层是基于中间件之上的开发框架与运行环境生成平台，包括各种生成环境与工具：如建模工具、可视化开发工具、第四代开发语言等；


3. 应用层，包含所有的应用，处于整个技术架构框架的最上层。

针对不同风格的数据架构和应用架构设计，其实现所需的技术栈是不同的。

正如序言所述，分行特色业务云平台是分布式服务架构向微服务架构的演进，使用更细粒度的服务和一组设计准则来实现大规模的、复杂的系统设计，并非一个纯粹的微服务架构风格的项目。

为了项目后期能顺利地迁移到微服务架构，此次的软件开发完全按照微服务架构的标准进行技术标准的制定和技术选型。

在进行微服务架构设计过程中，主要从以下几个方面考虑：

![img](微服务架构设计实践.assets/20180407204750677)

#####  4.4.4.2  技术架构设计原则

###### 4.4.4.2.1  系统运行时原则

应用或服务在运行时，应该提供如下特征：

![img](微服务架构设计实践.assets/20180407204817150)

#####  4.4.4.3  技术架构实践

分行特色业务云平台在实施过程中，由于项目进度、技术栈、研发团队等方面的约束，基础实施前期采用虚拟服务器集群，后期迁移到行方私有云，技术栈中的其它部分会根据具体情况有所微调，但基本不变。因此，在进行技术架构设计过程中，首先提供一个基于虚拟服务器集群的总体技术体系，然后再提供一个采用云部署的部署方案。

###### 4.4.4.3.1  总体技术体系

分行特色业务云平台的总体技术体系包括在项目整个生命周期过程中，软件开发人员需要遵循的技术规范，所使用的开发工具，开发、运行、运维过程中的技术、以及贯穿整个软件生命周期的过程管理工具。

依据微服务架构的关注点，结合行方目标业务量、研发团队规模、已有技术平台、开发语言约束（Java）等因素，所以，分行特色业务云平台的Java技术栈的技术选型如下：

1. 服务框架

- 选择Dubbo作为分布式服务框架，Tesla平台已经集成Dubbo；

- Dubbo提供了高性能和透明化的RPC远程服务调用方案，以及服务治理方案；


2. 运行时支撑服务

- 服务注册中心：采用Zookeeper作为服务注册中心；

- 服务网关：自主实现API网关，实现通讯协议解析，安全认证，流量控制，数据转换，协议转换等功能；

- 配置中心：自主实现基于DisConf的配置中心；

- 负载均衡：基于F5的硬负载，Dubbo提供的软负载等；


3. 服务部署平台

- 支持灰度发布；

- 基于行方私有云的容器调度、租户资源治理；

- 半自动化的服务发布流程（后面详细描述）；


4. 服务运行平台

- 第一阶段基于Linux虚拟机的集群部署；

- 后期迁移到私有云，基于docker容器集群部署；


5. 服务安全

- 基于角色的认证授权机制；

- 引入数字证书，对通讯数据进行签名、验签，保证用户的身份认证、通讯信息的完整性；

- 通过数字签名和数字时间戳，保证业务操作的不可抵赖性；


6. 服务容错

- 基于Dubbo实现服务的开关、限流、降级、超时等；


7. 服务监控

- 基于Logback分级记录系统运行日志、业务操作日志，并定期同步到日志归档平台；

- 通过自定义Spring注解实现服务调用链日志记录；

- 集成到Tesla监控平台，实现分行特色业务云平台运行状态的监控；


8. 后台服务

- 引入ZDAL，实现分布式数据访问层，支持分库分表；

- 基于Quartz自主实现自动任务调度；

- 自主实现本地内存缓存，采用Redis实现分布式数据缓存；


综合以上内容，分行特色业务云平台的总体技术体系如下图所示：

![img](微服务架构设计实践.assets/2018040720511744)

1. 开发工具

此次主要采用的开发工具如下：

- IDE:Spring Tool Suite；

- SDK:JDK1.7及以上；

- 单元测试：Junit、Mockito；

- 集成测试：待定；

- 性能测试：JMeter、LoadRunner；

- 代码生成器：自主研发的CodeGenerator；

- 业务流程设计器：自主研发的Activit Designer；


2. 技术规范

此次涉及的技术规范主要如下：

- 平台开发规范；

- 接口设计规范；

- 数据库设计规范；

- 统一返回码规范；

- 日志规范；

- 过程管理规范；

- QA规范；

- 投产运维规范；


3. 开发、运行环境

**一、WEB前端开发框架**

WEB前端采用Tesla平台自主研发的TESLA-UI框架，该框架采用时下比较流行的MVVM设计模式，使用SeaJS进行JavaScript模块化管理，提供了基于JQuery的UI组件库和UI皮肤库，以及基于HTML的布局模板，适用于企业管理类型前台页面的开发。

**二、服务开发框架** 

后台服务采用行方自主研发的Tesla平台，该平台采用“微内核”+“组件”设计，稳定的内核保证系统的健壮性，丰富的组件保证系统的灵活性、扩展性。

TESLA定义了良好的扩展机制和统一的模块交互机制，能够定制化地为应用系统提供各种基础功能，例如：IoC容器、数据访问、MVC框架、缓存、工作流、服务编排、系统集成、服务治理等等。

TESLA融合了诸多互联网领域的技术，包括高并发的Web服务端技术（WebX、SpringExt）、服务化架构下的服务治理技术（Dubbo）、大数据量分库分表技术（ZDAL）、分布式缓存技术（Redis、Memcached）、高性能数据源连接池技术（Druid）、分布式配置管理技术（Disconf）等等。

另外，TESLA具有应对金融领域业务系统复杂性的能力，在业务快速集成与分布式事务数据一致性处理上做了很多支持。

TESLA框架分层如下：

1. 渠道层：负责接收客户端发来的请求，不同的协议可以启用不同的渠道，比如有http、webservice、Socket等。

2. 业务功能层：抽象业务功能处理的概念，Function代表一个业务功能，Filter是过滤器（可以设置在不同的作用域，比如Function级别，Function组级别，整个应用级别）、Action是Function中执行的每一个活动，Context是整个架构的数据载体，PamameterProcesser是参数处理器，用于参数进行校验和转换。

3. 服务成层：Tesla采用“微内核”+“组件”设计，所有的服务组件都在这一层，都是开发中常用的一些基础功能，比如分页、缓存、工作流引擎、服务编排引擎、序列号生成器等。

4. 集成层：负责和外部系统进行交互，RPC调用、Ftp、消息中间件等，同时纳入到服务治理体系。

5. 开发工具集：全栈代码生成器，服务客户端代码生成器、业务流程设计器等。

6. 数据访问层：负责DAO数据库SQL操作（基于Mybatis）、管理数据库连接池、事务、基于ZDAL进行分库分表。

7. 基础设施：面向运维的一些支持设施，无需额外开发，如统一应用监控中心、配置管理中心、服务注册中心、异常处理平台集成等。

**三、中间件和技术平台**

1. 应用服务器

- 开发环境、单元测试环境：Tomcat7及以上；

- 集成测试环境、UAT测试环境、生产环境：Weblogic10；


2. WEB服务器

- 开发环境、单元测试环境：Tomcat7及以上；

- 集成测试环境、UAT测试环境、生产环境：Apache，Nginx；


3. 分布式数据一致性管理

- Zookeeper;


4. 缓存

- Redis


5. 容器

- Docker


6. JVM

- 开发环境、单元测试环境：Sun Hotspot 1.7及以上；

- 集成测试环境、UAT测试环境、生产环境：JRockit 7及以上；


**四、系统软件平台**

1. 数据库

总行：DB2 10及以上；

分行：根据分行具体情况任选其一：DB2、MySQL、Oracle；

2. 操作系统

- DB2数据库服务器：IBM AIX；

- 其它服务器：SUSE Linux；


**五、系统硬件平台**

使用行方现有的虚拟化服务器；

4. 过程管理

此次主要采用的过程管理工具如下：

- 项目构建：Maven；

- 版本控制：SVN；

- 构件仓库：Nexus；

- 缺陷跟踪：JIRA；

- 代码审查：FishEye、Crucible；

- 知识管理：Confluence；    

- 持续集成、持续交付：Bamboo；


###### 4.4.4.3.2  持续集成、持续交付

上述章节介绍了分行特色业务云平台的总体技术体系，在此，针对贯穿整个项目实施过程，保证项目质量、项目实施进度，减少项目实施风险的软件过程管理中的持续集成和持续交付的流程进行详细地说明，以便指导和约束整个软件实施过程。

正如本文《软件架构设计思想》章节中描述的，架构的本质就是通过“分“与”合“的手段，对系统进行有序化重构，不断减少系统无序的程度，使系统不断进化。

从一个简单的单体应用到分布式应用，再到更为复杂的微服务架构，除了关心如何拆、怎么拆的问题，还必须关注如何控制拆的风险、如何保证代码质量、如何保证功能符合用户需求等。

解决上述问题的手段就是集成，从一开始就集成，并且不断的集成，反复的将拆分的子系统、模块、组件重新组合，看看是否能够顺利组合起来，并且保证功能的不变。

实现上述不断地集成以及成果物交付的过程就是持续集成和持续交付：

1. 持续集成：指对代码的提交，构建，测试的过程，这是一个持续、反复的过程。

2. 持续交付：指将集成好的交付物，例如war、jar或者容器镜像，部署在联调环境，或者预发环境的过程。

以下是本项目采用的一个持续集成、持续交付的过程，研发团队在项目实施过程中要严格遵守：

![img](微服务架构设计实践.assets/20180407233815740)

持续集成、持续交付的基本流程如下：

1. 代码开发，完成分配的任务。

2. 每天提交代码，降低代码集成的风险。采用SVN的提交方式，后提交者有责任去merge，保证代码的编译通过和测试通过。

3. 专人定期审核提交的代码，把控代码质量。

4. 代码审核完毕之后，触发编译过程，完成代码编译。

5. 编译完成，进行单元测试。要求每个类都要有单元测试，并且单元测试覆盖率要达到一定的指标。单元测试要有带Mock的模块内的集成测试。如果单元测试不通过，则统计后发邮件，抄送所有的人。

6. 单元测试通过以后，上传成果物（war、jar或其它）至Nexus私服。

7. 如果采用私有云，并且使用docker容器，则需要编译Dockerfile，使用Docker镜像作为交付，能够实现更好的环境一致性，保证原子的升级和回滚。

8. 每天下班前，当天的代码需要提交到库中去，晚上会做一次统一的环境部署和集成测试。这个集成测试或者叫回归测试每天晚上都做，都是在一个全新的环境中。如果某一天测试不通过，则会发邮件通知。

9. 一个周期完毕，进行UAT测试。如果测试不通过，则会发邮件通知，开发人员要及时更正。

10. UAT测试通过以后，准备上线到生产环境。建议采用灰度发布或蓝绿发布机制，分批次发布、切换流量。一般情况下，具有权限的管理人员通过自动化脚本进行部署。

通过持续集成、持续交付这套完整的流程，层层保证质量，保证项目可以按时按质的完成，减少项目的实施风险。

#### 4.4.5  物理架构

##### 4.4.5.1  物理架构定义

物理架构定义了“程序”如何映射（安装、部署或烧写等）到“硬件”，以及“数据“如何在”硬件“上保存和传递。

物理架构必须考虑”功能的分布“和”数据的分布“这两个方面。

物理架构的设计着重考虑“安装和部署需求”，即软件系统最终如何安装或部署到物理机器。

物理架构视图描述运行软件的计算机、网络、硬件设施等情况，还包括如何将软件包部署到这些硬件资源上，以及它们运行时的配置情况。

另外，物理架构还要考虑软件系统和硬件在内的整体IT系统之间是如何相互影响的。由于一部分运行时质量属性需要硬件或网络的支持，所以物理架构必须关注如何配置硬件和网络来配合软件系统的可靠性、可伸缩性、高可用性、性能、安全性等方面的要求。

物理架构的设计主要完成下列工作：

1.	确定物理配置方案。

2.	确定如何将目标程序映射到物理节点。

##### 4.4.5.2  物理架构设计原则

###### 4.4.5.2.1  系统部署原则

应用或服务部署过程中，应该遵循以下原则：

![img](微服务架构设计实践.assets/20180407210507858)

##### 4.4.5.3  物理架构实践

###### 4.4.5.3.1  部署架构

在网络区域划分上，分行特色业务云平台采用行方现有的针对系统内部不同业务区域采用不同等级保护策略的网络区域。

在服务器部署方式上，分行特色业务云平台第一阶段采用集群部署，这样既可以避免单点失败，又可以根据实际用户量和并发访问量，在不影响系统正常运行的情况下，动态增加应用服务器和数据库服务器，提高了系统性能，同时又提高了系统的可用性；

分行特色业务云平台的物理架构图如下所示：

![img](微服务架构设计实践.assets/2018040721070016)

4.4.5.3.2  软硬件资源配置

在虚拟机集群部署情况下，分行特色业务云平台软硬件资源建议配置如下表所示：

![img](微服务架构设计实践.assets/20180407211131952)

另外，开通总行、分行之间的访问关系：

1.	分行应用服务器访问总行应用服务器（多台）。

2.	分行应用服务器访问总行注册中心（多台）。

3.	分行应用服务器访问总行监控中心（多台）。

###### 4.4.5.3.3  私有云部署

当分行特色业务云平台迁移到行方私有云时，从总体上来说，除底层的物理基础设施发生变化，其它技术基本还是遵循上述内容。

物理基础设施发生变化以后，服务部署方式如下图所示：

![img](微服务架构设计实践.assets/20180407222958638)

#### 4.4.6  开发架构

##### 4.4.6.1  开发架构定义

开发架构定义了软件开发环境中，软件模块的实际组织方式，具体涉及源程序文件、配置文件、源程序包、编译后的目标文件、第三方库文件等。

开发架构的设计着重考虑开发期质量属性，如可扩展性、可重用性、可移植性、易理解性和易测试性等。

为了避免开发人员不按照架构进行详细设计和编程，应该重视“开发架构视图”，让开发人员看到他们最关心的“程序单元“、”源代码目录结构“等内容，这些是不同程序团队开展具体工作的基础。如果程序员们不能从架构中看到上述内容，就会认为架构是一类“高来高去“的概念，就不会有积极态度。

从系统开发人员的角度来考虑问题，设计的架构要易于理解，易于开发，易于单元测试，最好做到让开发人员可以用最少的代码行数完成功能的开发。

开发架构设计要达到能支持并行的详细设计。

开发架构的设计主要完成下列工作：

1. 程序单元划分

- 源文件、配置文件；

- 程序库、框架；

- 目标单元；


2. 程序单元组织

- 项目划分；

- 项目目录结构；

- 编译依赖关系；


##### 4.4.6.2  开发架构设计原则

###### 4.4.6.2.1  模块内设计原则

对于模块内的代码设计，遵循SOLID原则：

![img](微服务架构设计实践.assets/20180407211529752)

1. S：单一责任原则，如果你的代码中有一个类行数太长，可能你需要重新审视一下，是不是这个类承担了过多的责任。

2. O：开放关闭原则，对扩展开放，对修改关闭。由于对于代码的直接修改是非常危险的事情，因为你不知道这段代码原来被谁用了，因此不要贸然修改一段代码，而是选择用接口进行调用，用实现进行扩展的方式进行。

3. L：里氏替换原则，如果基于接口进行编程，则子类一定要能够扩展父类的功能，如果不能，说明不应该继承与这个接口。例如你的实现的时候，发现接口中有一个方法在你这里实在对应不到实现，不是接口设计的问题，就是你不应该继承这个接口，绝不能出现not implemented类似之类的实现方法。

4. I：接口隔离原则，接口不应该设计的大而全，一个接口暴露出所有的功能，从而使得客户端依赖了自己不需要的接口或者接口的方法。而是应该讲接口进行细分和提取，而不应该将太过灵活的参数和变量混杂在一个接口中。

5. D：依赖倒置原则，A模块依赖于B模块，B模块有了修改，反而要改A，就是依赖的过于紧密的问题。这就是常说的，你变了，我没变，为啥我要改。如果基于抽象的接口编程，将修改隐藏在后面，则能够实现依赖的解耦。

###### 4.4.6.2.2  模块间设计原则

对于模块之间，则是采用云应用常说的十二原则，也称为云应用迁移原则。如果应用满足这12个要素，则可以比较顺利迁移到各种云平台。

![img](微服务架构设计实践.assets/20180407211654135)

1. 基准代码

一份基准代码，多份部署。如果用镜像部署方式，则一个镜像可以部署到多个环境 (测试，预发，生产)，而不是给每个环境制作一个不同镜像。

2. 依赖

显式声明依赖。如果用镜像部署，则一般依赖被直接打在镜像中，或者声明在dockerfile中。

3. 配置

在环境中存储配置。

4. 后端服务

把后端服务 (例如缓存，数据库，MQ 等) 当作附加资源，相关配置和连接字符串通过环境变量注入，或者采用配置中心。

5. 构建、发布和运行

严格分离构建和运行。如果使用镜像部署，则构建、发布、运行是通过镜像这种中间格式严格分离的。

6. 进程

一个或者多个无状态的进程运行应用。容器运行时相当于进程，适用于无状态 Web/API。

7. 端口绑定

通过端口绑定提供服务。容器也是通过端口绑定对外提供服务。

8. 并发

通过进程模型进行扩展。容器运行时相当于进程，通过起多个容器可以任意扩展并发数量。

9. 易处理

快速启动和优雅终止可最大化健壮性。docker 容器支持秒级启动和关闭。

10. 开发环境和线上环境等价

尽可能保持开发、测试、预发和线上环境相同。容器可以保证容器内运行时环境的一致性，还需要保证不同环境的一致性，例如不同环境内的操作系统，负载均衡，服务发现，后台服务，监控告警等要尽可能一致。

11. 日志

把日志当作数据流。

12. 管理进程

后台管理任务当作一次性的进程。

##### 4.4.6.3  开发架构实践-通用组件应用

###### 4.4.6.3.1  代码组织结构

![img](微服务架构设计实践.assets/20180407211943629)

1. 后台应用

按照模块分层进行组织，具体分为：

- 公共服务模块：bcap-common-base

- 总分通讯模块：bcap-common-client

- 日终模块：bcap-common-dayend

- 风控模块：bcap-common-riskcontrol

- 自动任务调度模块：bcap-common-scheduler

- 其它公共模块：bcap-common-模块名称

- 系统管理模块：bcap-common-rbac；(开发环境使用，生产环境采用Tesla统一应用监控配置中心进行部署)


2. 前台控制台

单独一个Web应用，调用后台应用提供的各种服务完成相关功能；

###### 4.4.6.3.2  模块依赖关系

1. bcap-common-base

该模块为全局公共模块，其它各模块以项目依赖的方式直接引用，在类中直接import该模块下的类。

模块依赖设置：（模块下pom.xml）

```xml
<dependency>
    <groupId>com.cmbc.bcap</groupId>
    <artifactId>bcap-common-base</artifactId>
    <version> ${bcap-common-version}</version>
</dependency>
```

2. 其它公共模块以Jar包方式、服务方式提供服务。

###### 4.4.6.3.3  目录结构

项目整体结构采用Maven的多级模块结构，本项目采用2级结构，即便于模块的分类管理，同时避免级数太多带来的代码管理方面的问题。

![img](微服务架构设计实践.assets/20180407213402560)

1. 一级目录：

bcap-common-parent

2. 二级目录：

- 后台应用模块：bcap-common-app

- 公共服务模块：bcap-common-base

- 分行服务调用客户端模块：scc-common-client

- 日终模块：bcap-common-dayend

- 风控模块：bcap-common-riskcontrol

- 自动任务调度模块：bcap-common-scheduler

- 其它公共模块：bcap-common-模块名称

- 前台应用模块：bcap-common-web


4.4.6.3.3.1	公共服务模块目录：（以base模块为例）

1. 项目结构采用Maven默认推荐结构：

- src/main/java存放应用Java代码；

- src/main/resources存放应用配置文件；

- src/test/java存放应用测试代码；

- src/test/resources存放应用测试配置；


2. Java代码目录层次：

此模块为全局共用模块，主要存放全局的常量定义、工具类、全局过滤器等。

- 常量类（constant）：存放本模块使用的常量定义；

- 工具类（util）：存放本模块使用的工具类；

- 过滤器（filter）：存放本模块使用的过滤器类；

- 其它：如果有特殊需要，可根据实际情况创建相关目录；


3. 日志配置文件：

统一存放在src/main/resources文件夹下，名称为logback.xml。

此为全局性的日志配置文件，在模块中不再单独需要日志配置文件。

4. log4j或logback日志文件：

建议预留一个磁盘空间比较大（至少50G）的磁盘专门用于存放日志文件。

5. 模块配置文件：

统一存放在src/main/resources/META-INF/common文件夹下。

配置文件包括，但不限于下述文件：

- datasource.xml

- security-realm.xml


4.4.6.3.3.2	其它公共模块目录：（以dayend模块为例）

1. 项目结构采用Maven默认推荐结构：

- src/main/java存放应用Java代码；

- src/main/resources存放应用配置文件；

- src/test/java存放应用测试代码；

- src/test/resources存放应用测试配置；


2. Java代码目录层次：

针对每个模块，采用Tesla通用的三层结构，具体划分为：

  1) 	业务层（function）：
  - 业务处理，在此层进行数据库事务控制；
    
  - 一个function对应一个业务功能，避免在一个function中定义多个业务功能；
    
  - 对于业务功能较多（大于等于20个业务功能）的模块，建议建立子目录，对function进行分类管理；
    
  - 对于同一个模块中功能可以进行分组管理；

  2) 	服务层（manager）：

  - 数据库组合操作，以便功能复用；

  - 对于function需要调用的mapper中的原子操作，也必须在manager层进行封装，即直接透传，不能在function中直接调用mapper中的功能；

  3)	数据访问层（mapper）：

- 数据库原子操作，例如：单表的增删改查、多表的关联查询等；

其它目录：

- 实体域（domain）：数据库表对应的Java Bean；

- 常量类（constant）：存放本模块使用的常量定义；

- 工具类（util）：存放本模块使用的工具类；

- 过滤器（filter）：存放本模块使用的过滤器类；

- 其它：如果有特殊需要，可根据实际情况创建相关目录；


3. MessageSource配置文件：

统一存放在src/main/resources/META-INF/模块名/messages文件夹下。

例如：src/main/resources/META-INF/dayend/messages；

4. MyBatis配置文件：

统一存放在src/main/resources/META-INF/模块名/services/mapper文件夹下。

例如：src/main/resources/META-INF/dayend/services/mapper；

5. 模块配置文件：

统一存放在src/main/resources/META-INF/模块名/services文件夹下。

例如：src/main/resources/META-INF/dayend/services；

基础配置文件包括，但不限于下述文件：

- mybatis-config.xml

- security.xml

- cache-config.xml


6. 初始化数据

统一存放在src/main/resources/initdata文件夹下。

##### 4.4.6.4  开发架构实践-总行服务融合中心

###### 4.4.6.4.1  代码组织结构

![img](微服务架构设计实践.assets/2018040721455682)


1.	后台应用

按照模块分层进行组织，具体分为：

  1)	公共服务：bcap-scc-common

  - 全局公共基础模块：bcap-scc-common-base

  - 其它公共服务模块：bcap-scc-common-模块名称

  2)	原子服务：bcap-scc-baseservice

  - 产品模块：bcap-scc-baseservice-product
  - 订单模块：bcap-scc-baseservice-order
  - 其它原子服务模块：bcap-scc-baseservice-模块名称

  3)	流程服务：bcap-scc-flowservice

  - 支付模块：bcap-scc-flowservice-payment
  - 信贷模块：bcap-scc-flowservice-credit
  - 其它流程服务模块：bcap-scc-flowservice-模块名称

  4)	系统管理模块：bcap-scc-rbac；(开发环境使用，生产环境采用Tesla统一应用监控配置中心进行部署)

2. 前台控制台单

独一个Web应用，调用后台应用提供的各种服务完成相关功能。

###### 4.4.6.4.2  模块依赖关系

1. 公共服务模块：

   1)	bcap-scc-common-base

该模块为总行服务融合中心公共模块，其它各模块以项目依赖的方式直接引用，在类中直接import该模块下的类。

模块依赖设置：（模块下pom.xml）

```xml
<dependency>
    <groupId>${parent.groupId}</groupId>
    <artifactId>${common-project-artifactId}</artifactId>
    <version>${parent.version}</version>
</dependency>
```

​    2) 其它公共服务模块

公共服务模块不依赖原子服务、流程服务；

2. 原子服务模块

- 支持模块热部署方式；

- 原子服务模块不依赖任何其他模块，除bcap-scc-common-base外；

- 各原子服务模块不对外提供服务；

- 各原子服务模块之间不能互相调用；

- 每个原子服务要独立完成一个完整的功能；


3. 流程服务模块

- 支持模块热部署方式；

- 流程服务模块依赖原子服务模块；

- 各流程服务模块通过Dubbo对外提供HTTP服务，采用JSON数据格式；

- 各流程服务模块通过Tesla平台提供的function-invoke调用原子服务模块提供的原子服务；

- 各流程服务模块之间不能互相调用；


###### 4.4.6.4.3  目录结构

![img](微服务架构设计实践.assets/20180407214640580)


项目整体结构采用Maven的多级模块结构，本项目采用3级结构，即便于模块的分类管理，同时避免级数太多带来的代码管理方面的问题；

1. 一级目录：

bcap-scc-parent

2. 二级目录：

- 后台应用模块：bcap-scc-app

- 公共服务模块：bcap-scc-common

- 原子服务模块：bcap-scc-baseservice

- 流程服务模块：bcap-scc-flowservice

- 前台应用模块：bcap-scc-web


3. 三级目录：

1)	公共服务目录bcap-scc-common：

- 公共模块：bcap-scc-common-base

- 其它公共服务模块：bcap-scc-common-模块名称


2)	原子服务：bcap-scc-baseservice

- 产品模块：bcap-scc-baseservice-product

- 订单模块：bcap-scc-baseservice-order

- 其它原子服务模块：bcap-scc-baseservice-模块名称


3)	流程服务：bcap-scc-flowservice

- 支付模块：bcap-scc-flowservice-payment

- 信贷模块：bcap-scc-flowservice-credit

- 其它流程服务模块：bcap-scc-flowservice-模块名称


**4.4.6.4.3.1	公共服务模块目录：（以base模块为例）**

![img](微服务架构设计实践.assets/20180407214910181)

1. 项目结构采用Maven默认推荐结构：

- src/main/java存放应用Java代码；

- src/main/resources存放应用配置文件；

- src/test/java存放应用测试代码；

- src/test/resources存放应用测试配置；


2. Java代码目录层次：

此模块为全局共用模块，主要存放全局的常量定义、工具类、全局过滤器等。

- 常量类（constant）：存放本模块使用的常量定义；

- 工具类（util）：存放本模块使用的工具类；

- 过滤器（filter）：存放本模块使用的过滤器类；

- 其它：如果有特殊需要，可根据实际情况创建相关目录；


3.日志配置文件：

统一存放在src/main/resources文件夹下，名称为logback.xml。

此为全局性的日志配置文件，在模块中不再单独需要日志配置文件。

4. log4j或logback日志文件：

建议预留一个磁盘空间比较大（至少50G）的磁盘专门用于存放日志文件。

5. 模块配置文件：

统一存放在src/main/resources/META-INF/common文件夹下。

配置文件包括，但不限于下述文件：

- datasource.xml

- security-realm.xml


**4.4.6.4.3.2	原子服务模块目录：（以pe模块为例）**

1. 项目结构采用Maven默认推荐结构：

- src/main/java存放应用Java代码；

- src/main/resources存放应用配置文件；

- src/test/java存放应用测试代码；

- src/test/resources存放应用测试配置；


2. Java代码目录层次：

针对每个模块，采用Tesla通用的三层结构，具体划分为：

1)	业务层（function）：

- 业务处理，在此层进行数据库事务控制；

- 一个function对应一个业务功能，避免在一个function中定义多个业务功能；

- 对于业务功能较多（大于等于20个业务功能）的模块，建议建立子目录，对function进行分类管理；

- 对于同一个模块中功能可以进行分组管理；


2)	服务层（manager）：

- 数据库组合操作，以便功能复用；

- 对于function需要调用的mapper中的原子操作，也必须在manager层进行封装，即直接透传，不能在function中直接调用mapper中的功能；


3)	数据访问层（mapper）：

- 数据库原子操作，例如：单表的增删改查、多表的关联查询等；


其它目录：

- 实体域（domain）：数据库表对应的Java Bean；

- 常量类（constant）：存放本模块使用的常量定义；

- 工具类（util）：存放本模块使用的工具类；

- 过滤器（filter）：存放本模块使用的过滤器类；

- 其它：如果有特殊需要，可根据实际情况创建相关目录；


3. MessageSource配置文件：

统一存放在src/main/resources/META-INF/模块名/messages文件夹下。

例如：src/main/resources/META-INF/pe/messages；

4. MyBatis配置文件：

统一存放在src/main/resources/META-INF/模块名/services/mapper文件夹下。

例如：src/main/resources/META-INF/pe/services/mapper；

5. 模块配置文件：

统一存放在src/main/resources/META-INF/模块名/services文件夹下。

例如：src/main/resources/META-INF/pe/services；

基础配置文件包括，但不限于下述文件：

- mybatis-config.xml

- security.xml

- cache-config.xml


6. 初始化数据

统一存放在src/main/resources/initdata文件夹下。

**4.4.6.4.3.3	流程服务模块目录：（以payment模块为例）**

![img](微服务架构设计实践.assets/20180407215413830)


1.	项目结构采用Maven默认推荐结构：

- src/main/java存放应用Java代码；

- src/main/resources存放应用配置文件；

- src/test/java存放应用测试代码；

- src/test/resources存放应用测试配置；


2. Java代码目录层次：

由于流程服务模块主要是根据需求对原子服务进行流程编排，所以在本模块只有function层，在function中进行服务流程的调用。
1)	业务层（function）：

业务流程调用；

- 一个function对应一个服务流程，避免在一个function中定义多个服务流程；

- 对于服务流程较多（大于等于20个服务流程）的模块，建议建立子目录，对function进行分类管理；

- 对于同一个模块中服务流程可以进行分组管理；


其它目录：

- 工具类（util）：存放本模块使用的工具类；

- 其它：如果有特殊需要，可根据实际情况创建相关目录；


3. MessageSource配置文件：

统一存放在src/main/resources/META-INF/模块名/messages文件夹下。

例如：src/main/resources/META-INF/payment/messages；

4. 模块配置文件：

统一存放在src/main/resources/META-INF/模块名/services文件夹下。

例如：src/main/resources/META-INF/payment/services；

基础配置文件包括，但不限于下述文件：

- channel-config.xml

- dubbo-config.xml

- security.xml

- security-client.xml

- serviceflow-config.xml


5. 服务编排流程文件

统一存放在src/main/resources/sflowDiagram文件夹下。

如果服务编排流程文件大于等于20个，可以参考function分类规则，在sflowDiagram目录下按照类别创建子目录进行分类管理。

6. 初始化数据

统一存放在src/main/resources/initdata文件夹下。

##### 4.4.6.5  开发架构实践-分行特色应用

以北京分行为例（bcap-bj）。

###### 4.4.6.5.1  代码组织结构

![img](微服务架构设计实践.assets/20180407215626686)


1.	后台应用

按照模块分层进行组织，具体分为：

- 公共服务模块：bcap-bj-base

- 贷款模块：bcap-bj-loan

- 其它模块：bcap-bj-模块名称

- 系统管理模块：bcap-bj-rbac；(开发环境使用，生产环境采用Tesla统一应用监控配置中心进行部署)


2.	前台控制台

单独一个Web应用，调用后台应用提供的各种服务完成相关功能。

###### 4.4.6.5.2  模块依赖关系

1.bcap-bj-base

该模块为公共模块，其它各模块以项目依赖的方式直接引用，在类中直接import该模块下的类。

模块依赖设置：（模块下pom.xml）

```xml
<dependency>
    <groupId>${parent.groupId}</groupId>
    <artifactId>${common-project-artifactId}</artifactId>
    <version>${parent.version}</version>	
</dependency>
```

###### 4.4.6.5.3  目录结构


项目整体结构采用Maven的多级模块结构，本项目采用2级结构，即便于模块的分类管理，同时避免级数太多带来的代码管理方面的问题。

1.	一级目录：

- bcap-bj-parent


2.	二级目录：

- 后台应用模块：bcap-bj-app

- 公共服务模块：bcap-bj-base

- 贷款模块：bcap-bj-loan

- 其它模块：bcap-bj-模块名称

- 前台应用模块：bcap-bj-web


**4.4.6.5.3.1	公共服务模块目录：**

参考《公共服务模块目录：（以base模块为例）》；

**4.4.6.5.3.2	其它模块目录：** 

参考《原子服务模块目录：（以pe模块为例）》；

##### 4.4.6.6  命名规则

1.项目名称：

1)	对前后台分开场景：以bcap-scc项目名称为例。

- 前台应用：bcap-scc-web；

- 后台应用：bcap-scc-app；


2)公共服务模块：

- 统一异常处理模块：bcap-scc-common-base；

- 其它公共服务模块：bcap-scc-common-模块名

3)	原子服务模块：

- 订单模块：bcap-scc-baseservice-order；

- 其它原子服务模块：bcap-scc-baseservice-模块名称

4)	流程服务模块：

- 支付模块：bcap-scc-flowservice-payment；

- 其它流程服务模块：bcap-scc-flowservice-模块名称


2. 公共服务模块包名：(以base为例）

- Function：com.cmbc.bcap.scc.common.base.function

- Manager：com.cmbc.bcap.scc.common.base.manager

- Mapper：com.cmbc.bcap.scc.common.base.mapper

- domain：com.cmbc.bcap.scc.common.base.domain

- util：com.cmbc.bcap.scc.common.base.util

- constant：com.cmbc.bcap.scc.common.base.constant

- filter：com.cmbc.bcap.scc.common.base.filter


3. 原子服务模块包名：(以订单模块order为例）

- Function：com.cmbc.bcap.scc.baseservice.order.function

- Manager：com.cmbc.bcap.scc.baseservice.order.manager

- Mapper：com.cmbc.bcap.scc.baseservice.order.mapper
- domain：com.cmbc.bcap.scc.baseservice.order.domain

- util：com.cmbc.bcap.scc.baseservice.order.util

- constant：com.cmbc.bcap.scc.baseservice.order.constant

- filter：com.cmbc.bcap.scc.baseservice.order.filter


4. 流程服务模块包名：(以支付模块payment为例）

- Function：com.cmbc.bcap.scc.flowservice.payment.function

- util：com.cmbc.bcap.scc.flowservice.payment.util


5. Function实现类名称：

业务功能名称+Function.java

如业务功能为订单查询，则对应的function名称为OrderQueryFunction；

注意：Function必须采用注解方式开发；

6. Manager类名称：

服务名称+Manager.java

如服务为客户账单服务，则对应的manager名称为ClientAccountManager.java；

7. Domain类名称：

实体名.java

如实体名为user，则对应的实体域名称为User.java；

8. Util类名称：

功能描述+Util.java

如日期格式转换工具类，则对应的工具类名称为DateFormatUtil.java；

9. 常量类名称

常量类别+Constant.java

如错误码类型常量，则对应的常量类名称为ErrorCodeConstant.java；

10. MyBatis中Mapper名称：

1)	Mapper接口类名称：

实体名+Mapper.java；

例如：UserMapper.java；

2)	Mapper接口类的方法名称：

- select、insert、update、delete方法分组定义，按顺序定义不能混乱；

- 方法名要能明确看出DB操作的含义，统一按照`select+xxx+By+yyy或select+xxx+List+By+yyy或select+xxx+withRS、insert+xxx、update+xxx、delete+xxx+By+yyy`。（xxx为实体名，yyy为条件描述，多重条件用简称描述）；

- 接口类中方法要有功能说明，描述DB操作的功能；

3)	Mapper配置文件名：

实体名+Mapper.xml，和接口类名称对应；

例如：UserMapper.xml；

4)	Mapper配置XML文件中配置项名：

- 同接口定义，select、insert、update、delete分组并按顺序定义，且按照接口方法的顺序在XML中定义；

- `<select></select>、<insert></insert>、<update></update>、<delete></delete>`的id名称与接口中方法名相同；

- `<sql></sql>`共享列定义id名称遵循：定义列为表的部分字段时为simple+xxx+Columns、定义列为表的所有字段时为full+xxx+Columns、定义列为表与其他表关联时为xxx+join+yyy+Columns。（xxx为主实体名、yyy为关联实体名）
- `<resultMap></resultMap>`返回结果映射定义id名称遵循：返回结果为表的部分字段时为simple+xxx+ResultMap、返回结果为表的所有字段时为full+xxx+ResultMap、返回结果为表与其他表关联时为xxx+join+yyy+ResultMap。（xxx为主实体名、yyy为关联实体名）
- `<sql></sql>和<resultMap></resultMap>`定义在XML的最前面，后面再开始定义`<select></select>、<insert></insert>、<update></update>、<delete></delete>`；

5)	MessageSource配置文件名：

实体名-message-source-zh_CN.properties

6)	MessageSource文件中配置项Key名称： 

function名称.消息码，统一小写；

例如：queryUserDetail.userid_not_exist；